<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Yebangyu's Blog]]></title>
  <link href="http://www.yebangyu.org/atom.xml" rel="self"/>
  <link href="http://www.yebangyu.org/"/>
  <updated>2018-04-06T21:48:41+08:00</updated>
  <id>http://www.yebangyu.org/</id>
  <author>
    <name><![CDATA[Yebangyu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【翻译】深入探索并发编程系列(一)：锁不慢；锁竞争慢]]></title>
    <link href="http://www.yebangyu.org/blog/2018/04/06/lock/"/>
    <updated>2018-04-06T21:19:05+08:00</updated>
    <id>http://www.yebangyu.org/blog/2018/04/06/lock</id>
    <content type="html"><![CDATA[<p>译者按：[Preshing] (http://preshing.com)的博客是学习并发编程的不可多得的资料，讲解比较详细。身边的很多朋友从中受益良多。</p>

<p>我们在和作者沟通后，获得了授权，着手翻译了他的博客，刊登在这里，以飨朋友诸君。</p>

<p>和一般的翻译不同，我们加上了独家的注释。注释要么是纠正错误，要么是辅助理解，要么是补充扩展；相信对大家会大有裨益。</p>

<p>希望朋友们能享受阅读！</p>

<p>锁(也叫互斥量)在很长一段时间都被误解了。1986年，在Usenet的有关于多线程的讨论会中，Matthew Dillon说过：大多数人都对锁有个误解，认为锁是慢的。25年后，这种误解似乎在某一时间段又突然出现了。</p>

<!--more -->

<p>在某些平台上或者当锁被高度竞争时，锁确实慢。另外，当你在开发一个多线程程序时，由于锁的引入，给性能带来巨大的瓶颈是很常见的。但这并不意味着所有的锁都是缓慢的。我会在这篇文章中解释，有的时候，使用锁的策略反而能带来非常好的性能。</p>

<p>大家对锁的误解可能源自于某个最容易忽视的原因：不是所有的程序员都会意识到轻量级锁和内核锁的区别。我会在下一篇文章中对轻量级锁做专门介绍:<a href="http://www.chongh.wiki/blog/2016/06/27/lightweightmutex/">总是使用轻量级锁</a>。在这篇文章中，假设你在Windows平台下做<code>C/C++</code>开发，你需要的正是一个<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682530.aspx">Critical Section</a>对象。</p>

<p>有时候，锁是慢的这个结论是由benchmark支撑的。例如，这篇文章在高负载状态下来测试锁的性能：每个线程必须持有锁来完成任何一项任务（高竞争），并且锁都是在极短的时间间隔下被持有（高频率）。这种方式似乎很完美，但在实际应用中，却要避免这种使用锁的方式<sup>注1</sup>。基于这种考虑，我设计了一种benchmark，同时包含对锁使用的最坏情况和最好情况。</p>

<p>由于一些其它的考虑，大家可能不愿意用锁了。存在一系列的技术被称为无锁编程(或者不含锁编程<sup>注2</sup>）。无锁编程是极具挑战性的，但其本身可以在许多实际应用场景下带来高度的性能回报。据我所知，有些程序员会花费许多天甚至几周的时间来设计某种无锁算法，之后再做一系列测试，但在几个月后才发现隐藏的bug. 风险与回报并存对于相当一部分程序员都是有诱惑力的，这当然也包括我，在以后的几篇文章中会提到这些。有了无锁编程的诱惑，大家开始觉得锁使用起来很枯燥，缓慢并且非常糟糕。</p>

<p>但也不能把锁贬的一文不值。在现实软件中，当大家为了保护内存分配器的时候，锁就是一个让人敬仰的东西。<a href="https://techcrunch.com/2016/07/01/exploiting-machine-learning-in-cybersecurity/?ncid=rss&amp;utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+Techcrunch+%28TechCrunch%29">Doug Lea的分配器</a>是在游戏开发中非常著名的内存分配器<sup>注3</sup>，但其只支持单线程，这时候我们就必须使用锁机制来进行保护。在游戏运行时，经常会碰到多个线程抢占一个内存分配器，每秒钟抢占次数可达到15000次左右。在加载过程中，每秒钟会达到100000次甚至更多。虽然这并不是个大问题。但你却可以看到，锁能非常出色的来处理这些负载。</p>

<h3 id="benchmark">锁竞争benchmark</h3>

<p>在这次测试中，我们创建一个线程来生成随机数，采用传统的<a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a>生成器来实现。此线程时而获取锁，时而释放锁。获取与释放锁的间隔时间是随机的，但它都很接近我们提前决策出的平均值。举个例子，假设我们要每秒钟获取锁15000次，让持有锁的时间保持在总时间的50%. 下图是部分的timeline。红色说明锁正在被持有，灰色说明锁被释放。</p>

<p><img src="http://7xppf1.com1.z0.glb.clouddn.com/mutex1.png" alt="MUTEX1" /></p>

<p>这是个泊松分布过程。如果我们知道生成单个随机数的平均时间–在2.66GHz的四核Xeon处理器上需要6.349ns–那么我们用工作单元(work units）而不是秒来衡量时间。可以用我之前的文章中介绍的方法,<a href="http://preshing.com/20111007/how-to-generate-random-timings-for-a-poisson-process/">How to Generate Random Timings for a Poisson Process</a>,算出获取与释放锁的时间间隔有多少个工作单元。下面代码是<code>C++</code>的实现。我省略了一些细节，喜欢的话，可以在 <a href="http://7xppf1.com1.z0.glb.clouddn.com/mutex5.zip">这里</a> 下载完整的源码</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="C++"><span class="line"><span class="n">QueryPerformanceCounter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
</span><span class="line"><span class="k">for</span> <span class="p">(;;)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// Do some work without holding the lock</span>
</span><span class="line">    <span class="n">workunits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">poissonInterval</span><span class="p">(</span><span class="n">averageUnlockedCount</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">);</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workunits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">random</span><span class="p">.</span><span class="n">integer</span><span class="p">();</span>       <span class="c1">// Do one work unit</span>
</span><span class="line">    <span class="n">workDone</span> <span class="o">+=</span> <span class="n">workunits</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">QueryPerformanceCounter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
</span><span class="line">    <span class="n">elapsedTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">QuadPart</span><span class="p">)</span> <span class="o">*</span> <span class="n">ooFreq</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">elapsedTime</span> <span class="o">&gt;=</span> <span class="n">timeLimit</span><span class="p">)</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Do some work while holding the lock</span>
</span><span class="line">    <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">criticalSection</span><span class="p">);</span>
</span><span class="line">    <span class="n">workunits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">poissonInterval</span><span class="p">(</span><span class="n">averageLockedCount</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">);</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workunits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">random</span><span class="p">.</span><span class="n">integer</span><span class="p">();</span>       <span class="c1">// Do one work unit</span>
</span><span class="line">    <span class="n">workDone</span> <span class="o">+=</span> <span class="n">workunits</span><span class="p">;</span>
</span><span class="line">    <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">criticalSection</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">QueryPerformanceCounter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
</span><span class="line">    <span class="n">elapsedTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">QuadPart</span><span class="p">)</span> <span class="o">*</span> <span class="n">ooFreq</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">elapsedTime</span> <span class="o">&gt;=</span> <span class="n">timeLimit</span><span class="p">)</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在假设我们运行两个这样的线程，每个线程运行在不同的CPU核心上。当执行任务时，每个线程有一半的时间是持有锁的，但如果其中一个线程在另一个线程持有锁的情况下试图获取锁，此线程会被强制等待。这就是锁竞争。</p>

<p><img src="http://7xppf1.com1.z0.glb.clouddn.com/mutex2.png" alt="MUTEX2" /></p>

<p>在我看来，这是锁在实际程序中应用的非常好的例子。当我们运行上述的场景时，可以发现每个线程会花费25%的时间在等待，75%的时间在执行实际的任务。与单线程相比，两个线程都获得了1.5X的性能提升。</p>

<p>我在2.66GHZ的四核Xeon处理器上做过不同的测试，从一个线程到两个线程，一直到最多四个线程的情况，每个线程都分别运行在不同的CPU核心上。同时，我还改变锁被持有的时间，从锁绝不被持有，到每个线程必须100%的时间持有锁。在所有的case中，锁频率保持一个常数–在执行任务过程中，线程每秒钟获取锁15000次。</p>

<p><img src="http://7xppf1.com1.z0.glb.clouddn.com/mutex3.png" alt="MUTEX3" /></p>

<p>结果很有意思。对于短的锁持有时间，比如持有时间占比&lt;10%的情况, 系统可能达到很高的并发性。虽然不是最完美的并发，但很接近。说明锁是非常快的！</p>

<p>为了把结果解释清楚一些，我用<a href="http://preshing.com/20111203/a-c-profiling-module-for-multithreaded-apis/">这个分析器</a>分析了多线程游戏引擎中的内存分配锁.在游戏运行时，每秒钟有15000个锁来自三个线程，锁的持有时间在2%左右。正好落在图表中左侧的舒适区(comfort zone).</p>

<p>这些结果都表明一旦锁持有时间超过90%，就没有必要再使用多线程了。这时，单线程会表现的更好。同时，最让人吃惊的是4个线程的性能都急剧下降到60%左右。这看起来像是个异常情况，所以我又重新运行这些测试很多次了，甚至还改变了测试顺序。得到的结果却是一样的。我对此最好的解释就是，测试可能触碰到了Windows分配器的盲区，我没有更进一步的去研究这个问题。</p>

<h3 id="benchmark-1">锁频率benchmark</h3>

<p>一个轻量级锁也会带来开销。正如我的<a href="http://www.chongh.wiki/blog/2016/06/27/lightweightmutex/">下一篇</a>文章中说的,对Windows Critical Section的lock/unlock成对操作会花费23.5ns（基于上述测试的CPU). 因此可以说明，每秒钟有15000个锁已经足够少了，锁的开销并不会在很大程度上影响整个结果。但如果我们提高锁频率，又会发生什么呢？</p>

<p>算法中，严格控制锁与锁之间执行的任务数，因此我做了一系列新的测试：锁与锁的间隔时间从10ns到最高31ns(相对应每秒钟大约32000次锁).每次测试都使用两个线程。</p>

<p><img src="http://7xppf1.com1.z0.glb.clouddn.com/mutex4.png" alt="MUTEX4" /></p>

<p>正如你想的那样，锁频率很高的话，锁本身的开销就已经高于所执行的任务本身了. 在网上找到的一些benchmarks,包括前面提到的那个分析器， 都落在图表中的右下角。在这些高频率下，和一些CPU指令的规模一样，锁的间隔比较小。好消息是，当锁与锁之间的任务比较简单的时候，无锁编程更可行。</p>

<p>与此同时，结果表明当锁频率达到每秒钟32000次时（锁间隔是3.1us)也是可以接受的。在游戏开发中，内存分配器就可能会在加载过程中达到这个频率。如果锁间隔比较短暂，你仍然可以得到1.5X的并发度。</p>

<p>我们已经了解了一系列锁性能的例子：有性能表现的很好的时候，也有性能慢的跟爬虫似的时候。我已经证明了游戏引擎中的内存分配器一直都能保持非常好的性能。把这个例子运用到实际场景中，不能说锁是慢的。不得不承认，锁很容易被滥用，但你不必太害怕–只要经过仔细的分析，任何情况下都能找出导致性能瓶颈的因素。当你正在考虑锁有多可靠，并去理解锁的相关优化方法时(相比无锁编程)，锁有时候表现的真的非常出色。</p>

<p>写这篇文章的目的是为了让锁得到应有的尊敬–欢迎批评指正。锁在工业应用程序中有广泛的应用，至于锁的性能，并不总是能达到一个很好的均衡。如果你在自己的经验中发现类似这样的例子，非常乐意看到你的评论<sup>注4</sup>。</p>

<h3 id="section">译者注</h3>

<p>注释1:一种避免或者降低锁冲突的科学思想是partition，避免资源集中。例如，对于hashtable，可以由之前的一个hashtable对应一把锁，改为每个bucket配置一把锁，这样冲突将大大降低。再例如，计数程序，如果大家都对同一个全局变量进行读写而加一把锁，那么冲突严重，可以适当的选择多个计数器，不同的线程累加对应的计数器，一个线程负责将这些计数器的值求和。等等等等。</p>

<p>注释2: 这里的无锁编程，原文为lock free。不含锁编程，原文为lockless。但是需要注意的是，lock free并不是无锁的意思，它的本质是说一组线程，总有（至少）一个线程能make progress，和有没有锁没有本质联系。lock free目前一般都翻译为无锁（有些地方也翻译为锁无关），因此本文也采用这种译法，但是读者需要特别注意。另外lockless就是真正的无锁、不包含锁的编程。</p>

<p>注释3: Doug Lea是并发编程的大牛，《Java并发编程实战》的作者之一，非常乐意分享。他写的这个分配器非常出名，glibc所采用的内存分配器实现就是基于他设计的算法。</p>

<p>注释4: 本文的描述和试验可能让人有点迷糊，这里提供一下Paul E. McKenney大叔在他的著作《Is Parallel Programming Hard, And, If So, What Can You Do About It?》中第4章中的例子来解释，让读者更好的理解：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class="C++"><span class="line"><span class="kt">pthread_rwlock_t</span> <span class="n">rwl</span> <span class="o">=</span> <span class="n">PTHREAD_RWLOCK_INITIALIZER</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">holdtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">thinktime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">readcounts</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">nreadersrunning</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="cp">#define GOFLAG_INIT 0</span>
</span><span class="line"><span class="cp">#define GOFLAG_RUN  1</span>
</span><span class="line"><span class="cp">#define GOFLAG_STOP 2</span>
</span><span class="line"><span class="kt">char</span> <span class="n">goflag</span> <span class="o">=</span> <span class="n">GOFLAG_INIT</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="o">*</span><span class="nf">reader</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">   <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">   <span class="kt">long</span> <span class="kt">long</span> <span class="n">loopcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">   <span class="kt">long</span> <span class="n">me</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class="line">   <span class="n">__sync_fetch_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nreadersrunning</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">   <span class="k">while</span> <span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">goflag</span><span class="p">)</span> <span class="o">==</span> <span class="n">GOFLAG_INIT</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="k">continue</span><span class="p">;</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="k">while</span> <span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">goflag</span><span class="p">)</span> <span class="o">==</span> <span class="n">GOFLAG_RUN</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwl</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="n">perror</span><span class="p">(</span><span class="s">&quot;pthread_rwlock_rdlock&quot;</span><span class="p">);</span>
</span><span class="line">       <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">     <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">holdtime</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">       <span class="n">barrier</span><span class="p">();</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwl</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="n">perror</span><span class="p">(</span><span class="s">&quot;pthread_rwlock_unlock&quot;</span><span class="p">);</span>
</span><span class="line">       <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">     <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">thinktime</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="n">barrier</span><span class="p">();</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">     <span class="n">loopcnt</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="n">readcounts</span><span class="p">[</span><span class="n">me</span><span class="p">]</span> <span class="o">=</span> <span class="n">loopcnt</span><span class="p">;</span>
</span><span class="line">   <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中16-18行等待测试开始的信号；19行开始测试；holdtime控制临界区的长短，thinktime用来控制两次申请锁之间的间隔。测试的时候有三个变量：holdtime、thinktime、线程数（1个、2个、4个、直到核数的两倍）。试试看。</p>

<h3 id="section-1">写在最后</h3>

<p>正文翻译：<a href="http://weibo.com/2767520802/profile?topnav=1&amp;wvr=6&amp;is_all=1">@Diting0x</a></p>

<p>审校 &amp;&amp; 注释：<a href="http://weibo.com/yebangyu">@睡眼惺忪的小叶先森</a></p>

<p>原文地址：[Preshing] (http://preshing.com/20111118/locks-arent-slow-lock-contention-is/)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017技术成长之路]]></title>
    <link href="http://www.yebangyu.org/blog/2017/03/11/2017/"/>
    <updated>2017-03-11T15:23:02+08:00</updated>
    <id>http://www.yebangyu.org/blog/2017/03/11/2017</id>
    <content type="html"><![CDATA[<p>记录2017年阅读过的技术相关的书籍、博客、Slides等</p>

<h2 id="machine-learning">Machine Learning</h2>

<p><a href="https://www.amazon.com/Deep-Learning-Adaptive-Computation-Machine/dp/0262035618/ref=sr_1_1?ie=UTF8&amp;qid=1489217130&amp;sr=8-1&amp;keywords=deep+learning">Deep Learning, By  Ian Goodfellow et al</a></p>

<p><a href="http://sebastianruder.com/optimizing-gradient-descent/">An overview of gradient descent optimization algorithms</a></p>

<p><a href="http://www.di.ens.fr/~fbach/fbach_tutorial_vr_nips_2016.pdf">Stochastic optimization: Beyond stochastic gradients and convexity. Part I</a></p>

<p><a href="http://www.di.ens.fr/~fbach/ssra_tutorial_vr_nips_2016.pdf">Stochastic optimization: Beyond stochastic gradients and convexity. Part II</a></p>

<p><a href="http://engineering.skymind.io/distributed-deep-learning-part-1-an-introduction-to-distributed-training-of-neural-networks">Distributed Deep Learning, Part 1: An Introduction to Distributed Training of Neural Networks</a></p>

<!--more-->

<h2 id="system">System</h2>

<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-deadlock/">一个Linux上分析死锁的简单方法</a></p>

<p><a href="http://david-grs.github.io/tls_performance_overhead_cost_linux/">TLS performance overhead and cost on GNU/Linux</a></p>

<p><a href="http://www.cubrid.org/blog/dev-platform/understanding-tcp-ip-network-stack/">Understanding TCP/IP Network Stack &amp; Writing Network Apps</a></p>

<p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">Understanding glibc malloc</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚函数和变长参数模板的妙用]]></title>
    <link href="http://www.yebangyu.org/blog/2017/02/17/virtualfunctionandvariadicparametertemplate/"/>
    <updated>2017-02-17T22:32:08+08:00</updated>
    <id>http://www.yebangyu.org/blog/2017/02/17/virtualfunctionandvariadicparametertemplate</id>
    <content type="html"><![CDATA[<p>假如我们需要设计和实现自己的容器，比如说vector，list，queue等。</p>

<p>同一类容器，我们可能有不同的实现和用途，因此我们抽象出了一个Base Class，比如说(以Vector为例)：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">BaseVector</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">pre_allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">SmallVector</span><span class="o">:</span> <span class="k">public</span> <span class="n">BaseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="c1">//一种特定的实现</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">pre_allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">p_</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">);</span> <span class="c1">//实际里可能不是malloc，而是自己实现的allocator</span>
</span><span class="line">   <span class="c1">//错误处理等等不在本文考虑范围之内</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">T</span><span class="p">();</span> <span class="c1">//预先构造好。注意，这里需要参数个数为0的默认构造函数</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="n">T</span> <span class="o">*</span><span class="n">p_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">class</span> <span class="nc">NoParameters</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="c1">//do something</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">NoParameters</span><span class="o">&gt;</span> <span class="n">vec0</span><span class="p">;</span>
</span><span class="line">  <span class="n">vec0</span><span class="p">.</span><span class="n">pre_allocate</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>没问题。一切完美。不过你试图这样使用vector类，就不行了：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">OneParameter</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="n">OneParameter</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="c1">//do something</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">OneParameter</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">;</span>
</span><span class="line"><span class="n">vec1</span><span class="p">.</span><span class="n">pre_allocate</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译不过，因为以上实现要求函数参数列表为空的默认构造函数，而OneParameter类（只）提供了带一个参数的构造函数，因此编译出问题，如下所示。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="p">..</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">hehe</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">19</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">matching</span> <span class="n">constructor</span> <span class="k">for</span> <span class="n">initialization</span> <span class="n">of</span> <span class="err">&#39;</span><span class="n">OneParameter</span><span class="err">&#39;</span>
</span><span class="line">      <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">T</span><span class="p">();</span>
</span><span class="line"><span class="mi">1</span> <span class="n">error</span> <span class="n">generated</span><span class="p">.</span>
</span><span class="line"><span class="nl">make</span><span class="p">:</span> <span class="o">***</span> <span class="p">[</span><span class="n">src</span><span class="o">/</span><span class="n">hehe</span><span class="p">.</span><span class="n">o</span><span class="p">]</span> <span class="n">Error</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>怎么办？使用C++11的变长参数模板，我们可以这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">BaseVector</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">pre_allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">Args</span><span class="p">...)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">SmallVector</span><span class="o">:</span> <span class="k">public</span> <span class="n">BaseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">pre_allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;small vector&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">p_</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">);</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="n">T</span> <span class="o">*</span><span class="n">p_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">FastVector</span><span class="o">:</span> <span class="k">public</span> <span class="n">BaseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">pre_allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;fast vector&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">p_</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">);</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="n">T</span> <span class="o">*</span><span class="n">p_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">class</span> <span class="nc">TwoParameters</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="n">TwoParameters</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="c1">//do something</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">class</span> <span class="nc">ThreeParameters</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="n">ThreeParameters</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="c1">//do something</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">TwoParameters</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">small_vec2</span><span class="p">;</span>
</span><span class="line">  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ThreeParameters</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">small_vec3</span><span class="p">;</span>
</span><span class="line">  <span class="n">FastVector</span><span class="o">&lt;</span><span class="n">TwoParameters</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">fast_vec2</span><span class="p">;</span>
</span><span class="line">  <span class="n">FastVector</span><span class="o">&lt;</span><span class="n">ThreeParameters</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">fast_vec3</span><span class="p">;</span>
</span><span class="line">  <span class="c1">////////////////////////////////////////////////////////</span>
</span><span class="line">  <span class="n">BaseVector</span><span class="o">&lt;</span><span class="n">TwoParameters</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">small_vec2</span><span class="p">;</span>
</span><span class="line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">  <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fast_vec2</span><span class="p">;</span>
</span><span class="line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">  <span class="c1">//////////////</span>
</span><span class="line">  <span class="n">BaseVector</span><span class="o">&lt;</span><span class="n">ThreeParameters</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">small_vec3</span><span class="p">;</span>
</span><span class="line">  <span class="n">q</span><span class="o">-&gt;</span><span class="n">pre_allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span><span class="line">  <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fast_vec3</span><span class="p">;</span>
</span><span class="line">  <span class="n">q</span><span class="o">-&gt;</span><span class="n">pre_allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>输出如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">small</span> <span class="n">vector</span>
</span><span class="line"><span class="n">fast</span> <span class="n">vector</span>
</span><span class="line"><span class="n">small</span> <span class="n">vector</span>
</span><span class="line"><span class="n">fast</span> <span class="n">vector</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>啊，看起来多么完美！！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Singleton与多线程]]></title>
    <link href="http://www.yebangyu.org/blog/2016/12/25/singleton/"/>
    <updated>2016-12-25T18:42:32+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/12/25/singleton</id>
    <content type="html"><![CDATA[<p>如果您和我一样，都只有C++背景，之前对设计模式也一窍不通，那么也没有关系，因为本文不需要您对设计模式有多么了解。</p>

<h2 id="singleton">Singleton模式</h2>

<p>所谓的单例模式，single instance模式，简单实现如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">Singleton</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">instance</span><span class="p">();</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">pInstance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">pInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<h2 id="singleton-1">多线程下的Singleton模式实现</h2>

<p>以上实现在单线程下运行良好（不考虑构造函数抛异常，注意，本文我们都不考虑C++ Exception）。如果是多线程呢？很自然的，我们想到可以加一把锁，或许就万事大吉了</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">LockGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">yourlock</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">pInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line">  <span class="c1">//guard析构，自动调用unlock</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="double-check-locking">double check locking</h2>

<p>前面的实现中，存在一个问题：因为只初始化一次，因此大部分情况下其实pInstance都不会为空，只需要简单返回pInstance。既然如此，何必大部分情况下都需要加锁呢？毕竟锁会带来不小的代价的。因此就引入了double check locking，降低锁的使用和冲突，fast path的时候尽最大可能没有任何锁的使用和开销：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">LockGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">yourlock</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">pInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//guard析构，自动调用unlock</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如你所见，当pInstance不为空时，不需要任何加锁、释放锁的动作，不过这回得两次检查pInstance是否为空。这是因为：假设线程1执行第三行，发现pInstance为空，还未执行第四行的时候，被调度了出去；线程2执行第三行，发现pInstance为空，获得锁，创建了实例，释放锁；当线程1重新恢复调度的时候，实例已经被创建，这时候它必须再次检查pInstance是否为空，否则就两次创建了，既不符合单例模式的语义，可能还会有其他更严重的问题（资源泄漏可能还算小事）。</p>

<h2 id="memory-reordering">memory reordering</h2>

<p>完美了？看起来很完美，但是问题很大。</p>

<p>注意其中的第6行：</p>

<p><code>pInstance = new Singleton();</code></p>

<p>它不是原子操作。这条语句，从逻辑和功能上包括三个部分：</p>

<p>1，分配内存空间，大小是sizeof(Singleton)</p>

<p>2，在该内存空间上调用Singleton的构造函数，完成初始化。</p>

<p>3，将pInstance指向该内存空间</p>

<p>信不信由你，编译器可能会对这三个步骤进行乱序，乱序后可能出现这样的情况：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">LockGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">yourlock</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">pInstance</span> <span class="o">=</span> <span class="k">operator</span> <span class="k">new</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Singleton</span><span class="p">));</span>
</span><span class="line">      <span class="k">new</span> <span class="p">(</span><span class="n">pInstance</span><span class="p">)</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//guard析构，自动调用unlock</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>也就是说，乱序后，编译器生成的代码的逻辑是：</p>

<p>1，分配内存单元。</p>

<p>2，将pInstance指向该内存空间。</p>

<p>3，在该内存空间调用构造函数，完成初始化。</p>

<p>乱序后，可能出现如下的data race：线程1执行完第六行后，pInstance不为空；线程2执行第三行判断，发现非空，返回，然而pInstance这时候还没有初始化，这几乎肯定会带来严重的问题。</p>

<h2 id="section">临时变量也于事无补</h2>

<p>你可能想使用一个temp指针来避开这个问题：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">LockGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">yourlock</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">Singleton</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">      <span class="n">pInstance</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//guard析构，自动调用unlock</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这下总没有问题了吧？有问题。聪明的非常aggressive的编译器会认为temp在这里是毫无必要的，因此会将它去除，根本不引入任何的temp，乱序还是会发生。</p>

<p>哦，你突然想到，volatile可能可以帮你的忙。因此，你可能将程序变为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">Singleton</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="k">static</span> <span class="k">volatile</span> <span class="n">Singleton</span><span class="o">*</span> <span class="k">volatile</span> <span class="n">instance</span><span class="p">();</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="k">static</span> <span class="k">volatile</span> <span class="n">Singleton</span><span class="o">*</span> <span class="k">volatile</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">volatile</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="k">volatile</span> <span class="n">pInstance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="k">volatile</span> <span class="n">Singleton</span><span class="o">*</span> <span class="k">volatile</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">LockGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">yourlock</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">volatile</span> <span class="n">Singleton</span> <span class="o">*</span><span class="k">volatile</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="k">volatile</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">      <span class="n">pInstance</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//guard析构，自动调用unlock</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>好多volatile，好吓人。简单解释一下：</p>

<p><code>volatile int * volatile p;</code></p>

<p>第一个volatile表明，p指向的内容随时可能会变</p>

<p>第二个volatile表明，p本身可能随时会变（p可能改变所指区域）</p>

<p>好了，temp也是volatile，我们试图这样，让编译器不要乱序。</p>

<p>然而，这是compiler dependent的，它可能会work，也可能不会work。如果它碰巧在我们的环境下是有效的，只能说我们是幸运的，然而它显然不可移植了。</p>

<h2 id="section-1">明确大胆的说出来</h2>

<p>不就是想防止编译器乱序吗？用了那么多volatile看得真心很烦。其实，我们需要的仅仅是一个memory barrier，防止编译器乱序。因此，我们应该显式的告诉编译器，比如这样(以gcc为例)：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">LockGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">yourlock</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">Singleton</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">      <span class="n">__asm__</span> <span class="nf">__volatile__</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
</span><span class="line">      <span class="n">pInstance</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//guard析构，自动调用unlock</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>是的，这里需要一个memory barrier，告诉编译器不要乱序。</p>

<p>即使这么做了，可能还是有问题。怎么说？C++标准并没有对多个线程读取同一个变量会发生什么进行任何规定。因此，上面的第3、第5、第8行存在data race，因此这是一个未定义的、不可移植的行为。</p>

<p>BTW，在X86下，问题不大，只要该指针是cacheline aligned即可。</p>

<p>让我们来分析下，在X86下，第3、5、8行的读写同步问题。假设该指针已经cacheline aligned，因此第3、5、8行的读写是原子的。</p>

<p>如果cpu 0上的线程1执行了第8行设置操作，在cpu 1上运行的线程2执行第3行。注意，这时候pInstance的新值对线程2不一定可见。然而这里不会有问题，因为：</p>

<p>1，假如可见，那么第3行if判断不成立，成功返回instance。</p>

<p>2，假如不可见，那么第3行if判断成立，此时pInstance实际上已经不为空，实例已经被创建。线程2尝试加锁操作，成功后，在第5行必然看到pInstance不为空，也就是看到pInstance的新值。</p>

<p>这是由锁的语义保证的：加锁解锁构成了一种synchronize with关系，加锁线程不管处在哪个处理器上，都可以看到上一个不管在哪个处理器上的释放锁的线程对变量的更新后的新值。</p>

<p>值得注意的是，为了防止第3行、第5行的读取pInstance的动作被编译器优化，可以使用<code>ACCESS_ONCE</code>宏。细节可以参考我的<a href="http://www.yebangyu.org/blog/2015/10/31/linux-parallen-programmming-infrastructure/">这篇</a>博客。</p>

<h2 id="c11">C++11来解救</h2>

<p>写出可移植的、线程安全的Singleton，这么难么？在C++11之前，很难。非常难。</p>

<p>现在，有了C++11，有了C++11的memory model，就不算太难了。</p>

<p>熟悉memory model的同学知道，其实我们这里需要的是一个acquire release语义。设置pInstance的时候使用release语义，读取pInstance的时候使用acquire语义。简单实现如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">Singleton</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">instance</span><span class="p">();</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="k">static</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">*&gt;</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">pInstance</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">Singleton</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">LockGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">yourlock</span><span class="p">);</span>
</span><span class="line">    <span class="n">temp</span> <span class="o">=</span> <span class="n">pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">      <span class="n">pInstance</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//guard析构，自动调用unlock</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>思考：第16行能否使用<code>memory_order_relaxed</code>内存序？</p>

<h2 id="section-2">拓展</h2>

<p>1，查阅资料，了解POSIX中，<code>pthread_once</code>的原理和用法</p>

<p>2，使用volatile的版本中，我们对指针和指针所指之物都加了volatile，也就是：</p>

<p><code>volatile Singleton *volatile p</code></p>

<p>能否改为</p>

<p><code>volatile Singleton *p</code></p>

<p>或者</p>

<p><code>Singleton * volatile p</code></p>

<p>3，查阅资料，解释为什么编译器可能对 <code>pInstance = new Singleton()</code> 进行乱序</p>

<p>4，我们一直没有涉及的一个问题是：pInstance的初始化。它的初始化，是否也可能存在data race？如何避免？</p>

<p>5，不少朋友可能想利用C++11标准中的某个用法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">static</span> <span class="n">Singleton</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">//C++11规定，这个是线程安全的。</span>
</span><span class="line">  <span class="k">return</span> <span class="n">xx</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然而这么做有一些缺点，这些缺点使得这种做法往往不是实现Singleton单例模式的可行方案。读者诸君不妨思考下，这种做法，都有哪些缺点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lock Free中的Hazard Pointer(下)]]></title>
    <link href="http://www.yebangyu.org/blog/2016/12/04/introductiontohazardpointer/"/>
    <updated>2016-12-04T17:29:10+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/12/04/introductiontohazardpointer</id>
    <content type="html"><![CDATA[<p>在前面几篇<a href="http://www.yebangyu.org/blog/2015/12/10/introduction-to-hazard-pointer/">文章</a>里，我们介绍了Hazard Pointer，一种用于lock free data structure设计中内存管理的利器，这个利器不仅思想简单，还可以用来防止ABA问题，读者诸君务必掌握。</p>

<p>本文作为第三部分，给出工业级代码中，实现Hazard Pointer的一些策略和需要注意的点。</p>

<h2 id="hazard-pointer">Hazard Pointer管理</h2>

<p>我们知道Hazard Pointer封装了原始指针，那么Hazard Pointer的内存和生命周期本身如何管理呢？以下是常见的策略：</p>

<!--more-->

<p>1，Hazard Pointer本身的内存只分配，不释放。在stack、queue等数据结构里，需要的Hazard Pointer数量一般为1或者2，所以不释放问题不大。对于skip list这种数据结构又有遍历需求的，那么Hazard Pointer可能就不是非常适用了，可以考虑使用<a href="http://www.yebangyu.org/blog/2016/09/09/epochbasedreclamation/">Epoch Based Reclamation</a>技术。据我所知，这也是memsql使用的内存回收策略。</p>

<p>2，每个线程拥有、管理自己的retire list和hazard pointer list ，而不是所有线程共享一个retire list，这样可以避免维护retire list和hazard pointer list的开销，否则我们可能又得想尽脑汁去设计另外一套lock free的策略来管理这些list，先有鸡先有蛋，无穷无尽。所谓retire list就是指逻辑删除后待物理回收的指针列表。</p>

<p>3，每个线程负责回收自己的retire list中记录维护的内存。这样，retire list是一个线程局部的数据结构，自己写，自己读，吃自己的狗粮。</p>

<p>4，只有当retire list的大小（数量）达到一定的阈值时，才进行GC。这样，可以把GC的开销进行分摊，同时，应该尽可能使用Jemalloc或者TCmalloc这些高效的、带线程局部缓存的内存分配器。</p>

<h2 id="acquirerelease">acquire和release动作</h2>

<p>所谓acquire，就是线程需要对一个资源进行访问，需要对它进行保护；所谓release，就是线程停止对资源的访问，结束对它的保护。</p>

<p>这两个动作基本上都是成对出现的，因此，可以封装成一个Guard。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line">   <span class="k">struct</span> <span class="n">HazardPointerRecord</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="n">HazardPointerRecord</span><span class="p">(</span><span class="n">HplfdsHazardPointer</span><span class="o">&lt;</span><span class="n">MemoryAllocator</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">manager</span><span class="p">,</span>
</span><span class="line">                          <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span><span class="o">:</span> <span class="n">manager_</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">        <span class="n">p_</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">        <span class="n">thread_id_</span> <span class="o">=</span> <span class="n">thread_id</span><span class="p">;</span>
</span><span class="line">        <span class="n">manager</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">p_</span><span class="p">,</span> <span class="n">thread_id_</span><span class="p">);</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="o">~</span><span class="n">HazardPointerRecord</span><span class="p">()</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">        <span class="n">manager_</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">p_</span><span class="p">,</span> <span class="n">thread_id_</span><span class="p">);</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="n">HplfdsHazardPointer</span><span class="o">&lt;</span><span class="n">MemoryAllocator</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">manager_</span><span class="p">;</span>
</span><span class="line">      <span class="kt">void</span> <span class="o">*</span><span class="n">p_</span><span class="p">;</span>
</span><span class="line">      <span class="kt">int</span> <span class="n">thread_id_</span><span class="p">;</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line">    <span class="cp">#define ACQUIRE_POINTER(p)\</span>
</span><span class="line"><span class="cp">  HazardPointerRecord record##p(memory_manager_, p, thread_id);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>更多细节，可以参考业余时间编写的<a href="https://github.com/yebangyu/HPLFDS/blob/master/src/queue/hplfds_ms_queue.h">lock free ms queue</a>中的用法。</p>

<h2 id="section">实现</h2>

<p>我在我的<a href="https://github.com/yebangyu/HPLFDS">HPLFDS</a>开源项目中，给出了一个<a href="https://github.com/yebangyu/HPLFDS/blob/master/src/hazardpointer/hplfds_hazard_pointer.h">实现</a>。虽然reclaim可以做的更加高效，然而在大部分场景下已经足够用了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化的那些传说和迷思]]></title>
    <link href="http://www.yebangyu.org/blog/2016/12/03/gccandperfopt/"/>
    <updated>2016-12-03T17:04:10+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/12/03/gccandperfopt</id>
    <content type="html"><![CDATA[<p>相信你在很多书籍中见到很多代码调优（tuning code）的建议和方法。这些书籍可能包括《编程珠玑》、《深入理解计算机系统》、《程序设计实践》、《Optimized C++》等等。坦白说，这些书我都看过，它们确实提供了不少有意思的性能调优的方法，那么我们的问题是，这些建议和方法有效吗？所谓有效，一种衡量途径是，假如我们不那么做，是否编译器已经会自动优化了呢？</p>

<p>本文我们举几个例子，然后开启编译器优化选项后，看看发生了什么。</p>

<p>本文环境为：Ubuntu 14.04 32bit + Intel I7 CPU + GCC 4.8</p>

<p>生成汇编代码的语句是：<code>g++ -S -O2 code.cpp</code></p>

<h2 id="section">循环展开</h2>

<p>对于下面的函数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>它们建议可以将循环展开，变成这样：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">  <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">  <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<p>OK，我们看看f1函数的反汇编代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line">    <span class="n">movl</span>    <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class="line">    <span class="n">addl</span>    <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
</span><span class="line">    <span class="n">addl</span>    <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
</span><span class="line">    <span class="n">addl</span>    <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
</span><span class="line">    <span class="n">ret</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>嗯，编译器已经自动帮你循环展开了。</p>

<p>练习：那么对于以下这种情况呢？是否有优化效果？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-1">循环条件去重</h2>

<p>对于以下函数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">g1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">xx</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">xx</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>它们建议你可以将第4行中的<code>strlen(p)</code>调用抽离出来放在循环开始前：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">g2</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">xx</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">xx</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>OK，我们看看g1函数的反汇编代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="p">.</span><span class="nl">LFB26</span><span class="p">:</span>
</span><span class="line">        <span class="n">pushl</span>   <span class="o">%</span><span class="n">ebx</span>
</span><span class="line">        <span class="n">subl</span>    <span class="err">$</span><span class="mi">24</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
</span><span class="line">        <span class="n">movl</span>    <span class="mi">32</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">),</span> <span class="o">%</span><span class="n">ebx</span>
</span><span class="line">        <span class="n">movl</span>    <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>
</span><span class="line">        <span class="n">call</span>    <span class="n">strlen</span> <span class="c1">//只有一次调用，不在循环里</span>
</span><span class="line">        <span class="n">movl</span>    <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
</span><span class="line">        <span class="n">leal</span>    <span class="p">(</span><span class="o">%</span><span class="n">ebx</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%</span><span class="n">ecx</span>
</span><span class="line">        <span class="n">xorl</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class="line">        <span class="n">jmp</span>     <span class="p">.</span><span class="n">L2</span>
</span><span class="line"><span class="p">.</span><span class="nl">L3</span><span class="p">:</span>
</span><span class="line">        <span class="n">movsbl</span>  <span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class="line">        <span class="n">addl</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
</span><span class="line">        <span class="n">addl</span>    <span class="err">$</span><span class="mi">9977</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class="line"><span class="p">.</span><span class="nl">L2</span><span class="p">:</span>
</span><span class="line">        <span class="n">cmpl</span>    <span class="o">%</span><span class="n">ecx</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
</span><span class="line">        <span class="n">jne</span>     <span class="p">.</span><span class="n">L3</span>
</span><span class="line">        <span class="n">addl</span>    <span class="err">$</span><span class="mi">24</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
</span><span class="line">        <span class="n">popl</span>    <span class="o">%</span><span class="n">ebx</span>
</span><span class="line">        <span class="n">ret</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译器已经帮你做了优化了。Why？本质原因是什么？</p>

<p>这是因为，首先，<code>strlen</code>函数的原型是：</p>

<p><code>size_t strlen(const char *p)</code></p>

<p>看到没，<code>const char</code>，也就是说这个函数不会改变输入参数，并且该函数不会对全局状态做一些设置和改变。而在函数g1内部，也只有对p的读，没有写，因此编译器可以放心地、大胆的做优化，把它当固定量。如果该函数可能有副作用，编译器是不会做这样的优化的。</p>

<p>因此，如果这里不是strlen，而是memcpy这样的函数，显然编译器无法做优化。如果这里不是strlen，而是你的一个辅助函数，比如说help，它的函数签名除了名字之外，和strlen一模一样。为了帮助gcc施展优化，你可以给gcc提供更多更好的提示和信息，比如说：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">attribute</span> <span class="p">((</span><span class="n">pure</span><span class="p">))</span> <span class="n">help</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>根据gcc文档，pure属性是用来修饰这样的函数：该函数除了返回一些值之外，不会产生其他作用和影响；并且它的返回值只依赖于它的输入参数和一些全局变量，比如说strlen和memcmp。</p>

<p>练习：实现一个简单的help函数，参数分别是<code>const char *p</code>和<code>volatile char *p</code>，查看gcc策略的差异。这个练习有助于让你发现，volatile是如何阻止编译器优化的。</p>

<h2 id="section-2">移位代替简单除法</h2>

<p>对于除以2，它们建议用移位来代替。比如说，对于下面的函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">h1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它们建议改为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">h2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>查看h1函数的反汇编代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line">    <span class="n">movl</span>    <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class="line">    <span class="n">shrl</span>    <span class="o">%</span><span class="n">eax</span> <span class="c1">//移位指令</span>
</span><span class="line">    <span class="n">ret</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>也就是说，编译器已经帮你做了优化。</p>

<p>练习：对于以下函数和“优化”，查看是否必要，是否有效</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">h1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对应的“优化”版本：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">h2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//括号不能丢哦。</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么，你可能会说了，什么是有效的呢？什么是编译器可能无法自动主动做的呢？你可以参考我的<a href="http://www.yebangyu.org/blog/2016/04/22/optimization/">这篇</a>博客。</p>

<h2 id="section-3">写在最后</h2>

<p>1，本文的演示仅仅是抛砖引玉，更重要的目的则有二：一是授人以鱼不如授人以渔，用一种方法和大家一起分析。二是，尽信书不如无书，必须报着怀疑的态度去读书，去验证，去思考。</p>

<p>2，教科书自然是强调原理的，强调思想的，它和实际有脱节这是无法避免的，也是必须这样的。无可厚非。我并不是说教科书说的这些优化不好，相反，如你所见，非常好。本文的目的是，很可能编译器已经帮你做了。</p>

<p>3，不同的编译器策略可能不同；同一个编译器不同版本策略可能也不同；同一个编译器的同一个版本在不同的上下文对于同一个函数的策略也可能不同。读者诸君务必不要过于相信本文，如我第一点所说：质疑！！！实践！！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个轻量的lock free程序调试工具]]></title>
    <link href="http://www.yebangyu.org/blog/2016/10/13/debuggerforlockfreeprogamming/"/>
    <updated>2016-10-13T22:39:29+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/10/13/debuggerforlockfreeprogamming</id>
    <content type="html"><![CDATA[<p>lock free 程序时序混乱，逻辑复杂，反直觉的地方很多，心智负担很重，因此调试起来也非常困难。</p>

<p>下面用C++编写了一个用于调试lock free代码的程序，非常轻量，代码如下，只适用于linux环境。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="c1">//xx.h</span>
</span><span class="line"><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">LockFreeLogger</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">struct</span> <span class="n">Event</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">;</span>
</span><span class="line">    <span class="kt">pthread_t</span> <span class="n">thread_id</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">info</span><span class="p">;</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="n">LockFreeLogger</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">pos_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="n">buffer_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Event</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">log</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="kt">int</span> <span class="n">info</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">__sync_fetch_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">    <span class="n">buffer_</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="p">;</span>
</span><span class="line">    <span class="n">buffer_</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
</span><span class="line">    <span class="n">buffer_</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">thread_id</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">report</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="c1">//single thread code</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">//cout or fwrite buffer_[i];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">pos_</span><span class="p">;</span>
</span><span class="line">  <span class="n">Event</span> <span class="o">*</span><span class="n">buffer_</span><span class="p">;</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">1234567</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">extern</span> <span class="n">LockFreeLogger</span> <span class="n">logger</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define LOG(message, info) logger.log(message, info)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<p>当然，为了能使用它，应该在某个cpp里面定义一个实例出来</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="c1">//xx.cpp</span>
</span><span class="line"><span class="cp">#include &quot;xx.h&quot;</span>
</span><span class="line"><span class="n">LockFreeLogger</span> <span class="n">logger</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后就可以使用<code>LOG(message, info)</code>来记录信息了。比如说<code>LOG("current value of counter", id)</code>等。读者诸君可以根据需要，自由拓展Event结构。</p>

<h2 id="section">注意事项</h2>

<p>1，<code>LockFreeLogger</code>构造函数里的内存分配操作可能会失败，工业级代码需要考虑异常或者错误处理。</p>

<p>2，数组下标可能会越界，达到或者超过SIZE。不过调试的时候可以考虑把SIZE设大一点，一般情况下也就够用了。</p>

<p>3，注意到这个调试程序有时候并不能work。为什么？举个简单的场景：假如你的lock free程序中存在一个bug，也就是两条语句之间漏加了memory barrier，导致乱序。</p>

<p>你没发觉，并在两条语句中间加了日志，想看看变量的值，结果因为加了代码，乱序不出现，bug不出现了。</p>

<p>4，编写这个程序的思想，是我自己想出来的。后来我在《Multi Core Programming》这本书的第八章看到了同样的idea，又后来看到了Jeff Preshing写了一篇<a href="http://preshing.com/20120522/lightweight-in-memory-logging/">博客</a>，介绍了一样的想法和做法，不过他的代码是针对Windows环境的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lock Free中的Epoch Based Reclamation]]></title>
    <link href="http://www.yebangyu.org/blog/2016/09/09/epochbasedreclamation/"/>
    <updated>2016-09-09T22:24:02+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/09/09/epochbasedreclamation</id>
    <content type="html"><![CDATA[<h2 id="section">楔子</h2>

<p>一般认为，用C/C++编写Lock Free代码非常困难，主要原因无非是两个：</p>

<blockquote>
  <ul>
    <li>内存模型</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>内存回收</li>
  </ul>
</blockquote>

<p>C++11引入了标准的内存模型，在此之前，C++程序员依赖于具体的体系结构特点和编译器提供的feature来保证正确的内存访问语义。C++11出来后，程序员编写健壮的、可移植的lock free代码成为可能。</p>

<p>但是内存回收问题依旧存在。我们知道，和Java这种提供自动gc的语言相比，C++程序员刀耕火种，得自己管理内存。当一个线程正在访问某块内存，而另外一个线程将它释放将是一个灾难行为。解决内存回收问题在lock free里显得更加困难。</p>

<p>目前用于lock free代码的内存回收的经典方法有：Lock Free Reference Counting、Hazard Pointer、Epoch Based Reclamation、Quiescent State Based Reclamation等。<a href="http://www.yebangyu.org/blog/2015/12/10/introduction-to-hazard-pointer/">上回</a>我们简单介绍了Hazard Pointer，本文我们介绍Epoch Based Reclamation方法。据我所知，这是第一篇介绍这个方法的中文资料。</p>

<!--more-->

<h2 id="section-1">概念</h2>

<p>1，逻辑删除和物理删除：逻辑删除仅仅是在逻辑上删除该节点，该节点在被逻辑删除之时可能会有其他线程正在访问它，而逻辑删除之后不会再被线程访问到。逻辑删除不回收内存空间。物理删除则是将对应的内存空间回收。一般逻辑删除对应delete，物理删除对应free或者reclaim。</p>

<p>2，Grace Period：记时间段T＝[t1,t2]，如果t1之前逻辑删除的节点，都可以在t2之后安全的回收，那么称T是一个Grace Period。t2之后保证不会有任何线程会访问在t1之前逻辑删除的节点。</p>

<p>3，临界区：在本文，临界区指的是线程访问共享内存资源的代码段。和传统上所说的临界区意义不同。</p>

<h2 id="section-2">实现</h2>

<p>我们依然先给出实现，再讲原理。注意到这里为了能focus我们的主题，我们刻意简化为四个线程，其中三个读线程，它们对数据都是只读的；而只有一个写线程可以对资源进行改写和删除，因此不需要加锁。</p>

<p>也请注意，以下伪代码只起示范作用，离真正生产环境实现还差很远。尽管如此，我们还是提供了一些实现细节和关键点(参考最后的思考一节)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#define N_THREADS 4 </span><span class="c1">//一共4个线程</span>
</span><span class="line"><span class="kt">bool</span> <span class="n">active</span><span class="p">[</span><span class="n">N_THREADS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="n">epoches</span><span class="p">[</span><span class="n">N_THREADS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="n">global_epoch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">retire_list</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">active</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">  <span class="n">epoches</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_epoch</span><span class="p">;</span>
</span><span class="line">  <span class="c1">//进入临界区了。可以安全的读取</span>
</span><span class="line">  <span class="c1">//...... </span>
</span><span class="line">  <span class="c1">//读取完毕，离开临界区</span>
</span><span class="line">  <span class="n">active</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">logical_deletion</span><span class="p">(</span><span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">active</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">  <span class="n">epoches</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_epoch</span><span class="p">;</span>
</span><span class="line">  <span class="c1">//进入临界区了，这里，我们可以安全的读取</span>
</span><span class="line">  <span class="c1">//好了，假如说我们现在要删除它了。先逻辑删除。</span>
</span><span class="line">  <span class="c1">//而被逻辑删除的tmp指向的节点还不能马上被回收，因此把它加入到对应的retire list</span>
</span><span class="line">  <span class="n">retire_list</span><span class="p">[</span><span class="n">global_epoch</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="c1">//离开临界区</span>
</span><span class="line">  <span class="n">active</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">  <span class="c1">//看看能不能物理删除</span>
</span><span class="line">  <span class="n">try_gc</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">bool</span> <span class="nf">try_gc</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">global_epoch</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">epoches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">//还有部分线程没有更新到最新的全局的epoch值</span>
</span><span class="line">        <span class="c1">//这时候可以回收(e + 1) % 3对应的retire list。</span>
</span><span class="line">        <span class="n">free</span><span class="p">((</span><span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">);</span><span class="c1">//不是free(e)，也不是free(e-1)。参看下面</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="c1">//更新global epoch</span>
</span><span class="line">  <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">  <span class="c1">//更新之后，那些active线程中，部分线程的epoch值可能还是e - 1（模3）</span>
</span><span class="line">  <span class="c1">//那些inactive的线程，之后将读到最新的值，也就是e。</span>
</span><span class="line">  <span class="c1">//不管如何，(e + 1) % 3对应的retire list的那些内存，不会有人再访问到了，可以回收它们了</span>
</span><span class="line">  <span class="c1">//因此epoch的取值需要有三种，仅仅两种是不够的。</span>
</span><span class="line">  <span class="n">free</span><span class="p">((</span><span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">);</span><span class="c1">//不是free(e)，也不是free(e-1)。参看下面</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">bool</span> <span class="nf">free</span><span class="p">(</span><span class="kt">int</span> <span class="n">epoch</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span> <span class="n">each</span> <span class="n">pointer</span> <span class="n">in</span> <span class="n">retire_list</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">pointer</span> <span class="n">is</span> <span class="n">not</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">      <span class="k">delete</span> <span class="n">pointer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-3">原理</h2>

<p>算法维护了一个全局的epoch(取值为0、1、2)和三个全局的retire_list（每个全局的epoch对应一个retire list, retire list 存放逻辑删除后待回收的节点指针）。除此之外我们为每个线程维护一个局部的active flag和epoch(取值自然也为0、1、2)。</p>

<h3 id="section-4">读线程</h3>

<p>首先设置自己的active flag 为true，表明自己需要访问共享内存。然后将自己的局部的epoch设置为全局的epoch值。</p>

<p>这之后线程就进入临界区，可以放心的读取资源了，不用担心内存会被回收。</p>

<p>离开临界区时，将自己的active flag设置为false即可。</p>

<h3 id="section-5">写线程</h3>

<p>这里说的写线程是指会对资源进行删除的线程。首先进行逻辑删除，然后尝试对它进行物理删除，也就是回收。</p>

<p>令全局的epoch值为e。首先检查，如果存在活动线程的局部epoch值不等于全局epoch值，那么可以回收retire_list[(e+1) % 3]。</p>

<p>如果不存在，那么我们把全局epoch的值更新为(e+1)%3，然后再回收对应的retire list。</p>

<p>有点绕？这里关键是理清线程局部epoch和全局epoch的关系：在这个算法里，任何时刻，全局epoch的值如果为e，那么线程的局部epoch值要么也为e，要么为e-1，不可能为e+1。</p>

<p>所以[epoch, epoch + 2]（模3）构成了一个Grace Period。</p>

<p>当全局epoch的值为1的时候，线程的局部epoch要么是1，要么是0，不可能是2。因此[2,1]构成了一个Grace Period，也就是说2对应的retire list这时候可以放心的回收了。</p>

<p>当全局epoch的值为0的时候，线程的局部epoch要么是0，要么是2，不可能是1。因此[1,0]构成了一个Grace Period，也就是说1对应的retire list这时候可以放心的回收了。</p>

<p>当全局epoch的值为2的时候，线程的局部epoch要么是2，要么是1，不可能是0。因此[0,2]构成了一个Grace Period，也就是说0对应的retire list这时候可以放心的回收了。</p>

<p>也因此，当全局epoch值为2时，如果存在部分活跃线程的局部epoch等于1，那么retire_list[1]将不能立马回收。如果这些活跃线程不退出临界区（在里面不断的读、疯狂的读，或者死了），那么retire_list[1]纪录的那些内存将一直无法回收。</p>

<p>这也就是在Epoch Based Reclamation中，回收操作可能被读延迟的原因所在。</p>

<h2 id="section-6">思考</h2>

<p>1，代码中8、9两行是写一个变量(active[i])，读另外一个变量(global_epoch)，在x86下可能会乱序，这里是否需要一个cpu级别的memory barrier？如果被乱序，有没有影响？</p>

<p>2，<code>retire_list[global_epoch].push_back(tmp);</code> 能否改为 <code>retire_list[epoches[thread_id]].push_back(tmp);</code> ？也就是说这里能否改为使用线程局部epoch值？</p>

<p>3，和Hazard Pointer相比，Epoch Based Reclamation 有什么优点和缺点？</p>

<p>4，为什么epoch有三个取值0、1、2？能不能仅使用两个？</p>

<p>5，线程局部变量我们使用了<code>active</code>数组和<code>epoches</code>数组，这里会有性能问题，为什么？提示：<a href="http://www.yebangyu.org/blog/2015/12/30/falsesharing/">False Sharing</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MCS Lock]]></title>
    <link href="http://www.yebangyu.org/blog/2016/08/21/mcslock/"/>
    <updated>2016-08-21T20:25:11+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/08/21/mcslock</id>
    <content type="html"><![CDATA[<h2 id="section">回顾</h2>

<p><a href="http://www.yebangyu.org/blog/2016/05/26/ticketlock/">上回</a> 我们介绍了Ticket Lock算法，和传统的简单的CAS操作来实现spin lock相比，它提供了不少很好的性质：比如FIFO、没有饥饿等等。</p>

<p>但是根据<a href="https://pdos.csail.mit.edu/papers/linux:lock.pdf">论文</a>，ticket lock的scalability很差。我们不妨简单回顾一下（代码片段也摘自该论文）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">struct</span> <span class="kt">spinlock_t</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">current_ticket</span> <span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">next_ticket</span> <span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="n">spin_lock</span> <span class="p">(</span><span class="kt">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">atomic_fetch_and_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span> <span class="o">-&gt;</span> <span class="n">next_ticket</span> <span class="p">);</span>
</span><span class="line">  <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">current_ticket</span> <span class="p">)</span>
</span><span class="line">  <span class="p">;</span> <span class="cm">/* spin */</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="n">spin_unlock</span> <span class="p">(</span><span class="kt">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">lock</span><span class="o">-&gt;</span><span class="n">current_ticket</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<p>正如论文中指出的那样，当某个core上持有锁的线程释放锁时，它将把其他core上的<code>current_ticket</code>对应的cacheline都invalid掉，之前所有等锁的线程都会通过bus来读取最新的cacheline，这将造成“拥堵”(也就是所谓的bus traffic)。由于在绝大多数体系结构下，这些读取请求都会被串行化，one by one的处理，因此<code>spin_lock</code>所需时间将正比于等待锁的线程数目。</p>

<p>本质上，这里的问题还是在于资源共享：所有等锁线程都spin在同一个全局变量上。如果每个线程仅仅spin在本地变量(该线程私有的变量)，那么将有效的提高scalability。本文要介绍的MCS Lock就是这样的思路。</p>

<h2 id="section-1">实现</h2>

<p>这次，我们先给出实现（环境为：GCC 4.8 + X86体系结构 + Ubuntu 14.04 32bit系统），然后再讲解算法。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#define COMPILER_BARRIER() __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;)</span>
</span><span class="line"><span class="cp">#define CPU_RELAX() __asm__ __volatile__(&quot;pause\n&quot;: : :&quot;memory&quot;)</span>
</span><span class="line"><span class="cp">#define CAS(address, exp, target) __sync_bool_compare_and_swap(address, exp, target)</span>
</span><span class="line"><span class="cp">#define ATOMIC_EXCHANGE(address, val) __atomic_exchange_n(address, val, __ATOMIC_SEQ_CST)</span>
</span><span class="line"><span class="cp">#define CPU_BARRIER() __sync_synchronize()</span>
</span><span class="line"><span class="c1">//=========================================</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">mcs_lock_node</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">waiting</span><span class="p">;</span>
</span><span class="line">  <span class="n">mcs_lock_node</span> <span class="o">*</span><span class="k">volatile</span> <span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">typedef</span> <span class="n">mcs_lock_node</span> <span class="o">*</span><span class="k">volatile</span> <span class="n">mcs_lock</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="n">mcs_lock_node</span><span class="o">*</span> <span class="nf">get_my_mcs_node</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">static</span> <span class="n">__thread</span> <span class="n">mcs_lock_node</span> <span class="n">my_mcs_node</span><span class="p">;</span>
</span><span class="line">  <span class="k">return</span> <span class="o">&amp;</span><span class="n">my_mcs_node</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">spin_lock</span><span class="p">(</span><span class="n">mcs_lock</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">mcs_lock_node</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">get_my_mcs_node</span><span class="p">();</span>
</span><span class="line">  <span class="n">mcs_lock_node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
</span><span class="line">  <span class="n">mcs_lock_node</span> <span class="o">*</span><span class="n">pre</span><span class="p">;</span>
</span><span class="line">  <span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">  <span class="n">pre</span> <span class="o">=</span> <span class="n">ATOMIC_EXCHANGE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span><span class="p">;</span>	
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">me</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="n">COMPILER_BARRIER</span><span class="p">();</span>
</span><span class="line">  <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
</span><span class="line">  <span class="k">while</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">waiting</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">CPU_RELAX</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">CPU_BARRIER</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">spin_unlock</span><span class="p">(</span><span class="n">mcs_lock</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">CPU_BARRIER</span><span class="p">();</span>
</span><span class="line">  <span class="n">mcs_lock_node</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">get_my_mcs_node</span><span class="p">();</span>
</span><span class="line">  <span class="n">mcs_lock_node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">      <span class="k">return</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">CPU_RELAX</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">算法</h2>

<p>MCS Lock算法维护一个队列(队尾指针tail)。</p>

<p>lock：尝试加锁的线程首先获得自己的节点，接着通过原子操作<code>ATOMIC_EXCHANGE</code>，将自己插入队列中，并获得插入前队尾指针tail。如果tail指针为空，说明当前锁是空闲的，没有被任何线程占用，因此获得锁成功；如果tail指针不空，那么设置自己的前驱，然后自旋，等待它的前驱(线程)将自己的<code>waiting</code>域置为0。<code>waiting</code>域一旦为0，那么线程结束spin，该线程就变成锁的持有者了。</p>

<p>unlock：释放锁的线程需要检查是否存在后继，如果存在后继，那么将它的后继的<code>waiting</code>域设置为0即可，后继将结束spin，成功获得锁。一切搞定，如54行代码所示。</p>

<p>如果不存在后继，那么这里需要特别特别注意。不存在后继有两种可能：</p>

<p>它是最后一个线程。47-49行处理的就是这种情况。那么这时候只需要把队列置为空即可。</p>

<p>它不是最后一个线程。那么此时存在另外一个线程在进行加锁操作，尝试加锁的线程已经通过28-33行设置了新的队尾指针，但是还没设置它的前驱，也就是还没执行到34行。因此释放锁的线程需要等待，等待34行被其他线程执行，等待它被人设置为别人的前驱。这也就是50-52行所做的事。</p>

<p>简单说来，MCS Lock就是将线程们用队列管理起来；加锁的线程spin在自己的变量上；释放锁的线程只更新它后继的变量。</p>

<h2 id="section-3">练习</h2>

<p>1，MCS Lock的优点是显而易见的，因为每个等待锁的线程都spin在自己的局部的变量上。以至于新版的linux内核已经开始采用它，来代替之前的ticket lock实现。那么，它的缺点呢？</p>

<p>2，列出表格，从公平性、是否出现饥饿、时间空间复杂度等方面，全面对比ticket lock、mcs lock、peterson lock等。</p>

<p>3，编写程序测试这几个算法的性能，考察它们的scalability。</p>

<h2 id="section-4">附录</h2>

<p>MCS Lock测试程序Demo</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;pthread.h&gt;</span>
</span><span class="line"><span class="n">mcs_lock</span> <span class="n">global_lock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span><span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">spin_lock</span><span class="p">(</span><span class="n">global_lock</span><span class="p">);</span>
</span><span class="line">    <span class="n">spin_unlock</span><span class="p">(</span><span class="n">global_lock</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">pthread_t</span> <span class="n">pthread1</span><span class="p">;</span>
</span><span class="line">  <span class="kt">pthread_t</span> <span class="n">pthread2</span><span class="p">;</span>
</span><span class="line">  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthread1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthread2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">pthread_join</span><span class="p">(</span><span class="n">pthread1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">pthread_join</span><span class="p">(</span><span class="n">pthread2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现可重入锁]]></title>
    <link href="http://www.yebangyu.org/blog/2016/07/12/reentrantlock/"/>
    <updated>2016-07-12T20:27:25+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/07/12/reentrantlock</id>
    <content type="html"><![CDATA[<h2 id="section">基本概念</h2>

<p>可重入锁(Reentrant Lock)，是指允许同一个线程多次对该锁进行acquire动作。对于不可重入的锁，当一个线程多次调用acquire后将造成死锁。可重入锁具有广泛的应用，例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">struct</span> <span class="n">Routine</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">lock_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class="line">    <span class="n">h</span><span class="p">();</span>
</span><span class="line">    <span class="n">g</span><span class="p">();</span>
</span><span class="line">    <span class="n">lock_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">g</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">lock_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">lock_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">h</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">lock_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;def&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">lock_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">Lock</span> <span class="n">lock_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<p>在函数f里调用了g和h，而在每个函数里都试图对lock进行acquire操作。可能你会说保证只有一个函数加锁就行了，但是有时候很难做成这个样子，毕竟一般我们都要求任何一个public函数被调用时候都得保证是线程安全因此需要加锁的。</p>

<p>那么，reentrant lock和recursive lock有什么区别呢？根据<a href="https://en.wikipedia.org/wiki/Reentrant_mutex">wikipedia</a>，这两个是一样的。</p>

<h2 id="section-1">基本实现</h2>

<p>自己实现一个可重入锁并不困难：我们增加两个field，一个用来记录锁当前被哪个线程拥有；一个用来记录尝试acquire的次数。如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &lt;stdint.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class="line"><span class="n">Class</span> <span class="n">MyReentrantLock</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="n">MyReentrantLock</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">lock_holder_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">hold_counter_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock_</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">lock</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">pthread_t</span> <span class="n">curr_id</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">lock_holder_</span> <span class="o">==</span> <span class="n">curr_id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="o">++</span><span class="n">hold_counter_</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">      <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock_</span><span class="p">);</span>
</span><span class="line">      <span class="n">lock_holder_</span> <span class="o">=</span> <span class="n">curr_id</span><span class="p">;</span>
</span><span class="line">      <span class="n">hold_counter_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">unlock</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">pthread_t</span> <span class="n">curr_id</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">lock_holder_</span> <span class="o">!=</span> <span class="n">curr_id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">hold_counter_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">lock_holder_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock_</span><span class="p">);</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="kt">pthread_mutex_t</span> <span class="n">lock_</span><span class="p">;</span>
</span><span class="line">  <span class="kt">pthread_t</span> <span class="n">lock_holder_</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">hold_counter_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>顺便说一句，默认pthread_mutex_t是不可重入的。为了让它可重入，可以这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
</span><span class="line"><span class="kt">pthread_mutexattr_t</span> <span class="n">attr</span><span class="p">;</span>
</span><span class="line"><span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</span><span class="line"><span class="n">pthread_mutexattr_settype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_MUTEX_RECURSIVE</span><span class="p">);</span><span class="c1">//设置可递归也就是可重入</span>
</span><span class="line"><span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">参考文献</h2>

<p>1，《The Art Of Multiprocessor Programming》 8.4节，187页</p>

<p>这本书的作者都是并发编程大仙级人物。虽然是用Java语言写的，但是还是很值得一读。</p>

<p>2，<a href="http://preshing.com/20120305/implementing-a-recursive-mutex/">Implementing a Recursive Mutex</a></p>

<p>很好的博客，每篇都非常高水准。我们最近正在翻译其中和并发编程相关的文章。可以点击这里查看：<a href="http://www.chongh.wiki/categories/High-performance/">深入探索并发编程系列</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sequence Lock]]></title>
    <link href="http://www.yebangyu.org/blog/2016/06/26/sequence-lock/"/>
    <updated>2016-06-26T14:24:59+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/06/26/sequence-lock</id>
    <content type="html"><![CDATA[<p>在读多写少(Read Mostly)的场景里，我们可能会使用的同步设施包括：</p>

<blockquote>
  <ul>
    <li>Mutex / Spin Lock</li>
    <li>Reader Writer Lock</li>
    <li>Sequence Lock</li>
    <li>Read Copy Update</li>
  </ul>
</blockquote>

<p>前面两种一般人都很清楚了，如雷贯耳、妇孺皆知。如果您对Spin Lock的实现细节有兴趣，建议您阅读我的这几篇博客：</p>

<p><a href="http://www.yebangyu.org/blog/2016/03/04/petersonalgorithm/">Peterson Lock</a></p>

<p><a href="http://www.yebangyu.org/blog/2016/05/26/ticketlock/">Ticket Lock</a></p>

<p><a href="http://www.yebangyu.org/blog/2016/08/21/mcslock/">MCS Queue Lock</a></p>

<p>从今天起，我们介绍后面两种同步设施。今天我们先介绍Sequence Lock。</p>

<!--more-->

<h2 id="section">基本原理</h2>

<p>我们知道，传统的Reader Writer Lock是reader preference的，可能会产生writer starvation。和Reader Writer Lock不同，sequence lock是writer preference的，writer随时都可以更新临界资源。</p>

<p>sequence lock的精髓在于一个sequence count。当writer在更新时，count为奇数；不存在writer更新时，该count为偶数。</p>

<p>count初始化为一个偶数，比如说0。当writer操作临界资源前，先将count++，这时候count变成奇数；然后writer操作临界资源，完毕后，再count++，这时候count将又恢复为偶数。</p>

<p>对于reader，每次进入临界区前读取count值，如果为偶数，说明没有writer存在，那么它可以进入临界区；如果为奇数，那么它需要等待，不断重试，读取count直到count为偶数。进入临界区读取临界资源后，你知道，从reader进入临界区到试图离开临界区这段时间里，可能writer进来了，因此reader需要重新读取count，看和它进入临界区时的count是否相等，不等的话说明此次读取失败，需要重试。</p>

<h2 id="section-1">基本实现</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;mutex&gt; </span><span class="c1">//c++11的mutex</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">SequenceLock</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">volatile</span> <span class="kt">uint64_t</span> <span class="n">sequence_count</span><span class="p">;</span>
</span><span class="line">  <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span> <span class="c1">//这把锁是用于writer们互斥的。保证只有一个writer能更新。和reader无关。</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">seqlock_init</span><span class="p">(</span><span class="n">SequenceLock</span> <span class="o">&amp;</span><span class="n">sl</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">sl</span><span class="p">.</span><span class="n">sequence_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//初始化为偶数</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">read_seqbegin</span><span class="p">(</span><span class="n">SequenceLock</span> <span class="o">&amp;</span><span class="n">sl</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">uint64_t</span> <span class="n">sc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">sc</span> <span class="o">=</span> <span class="n">sl</span><span class="p">.</span><span class="n">sequence_count</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">      <span class="k">break</span><span class="p">;</span> <span class="c1">//sc是偶数，说明没有writer，返回</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">sc</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">reader_need_retry</span><span class="p">(</span><span class="n">SequenceLock</span> <span class="o">&amp;</span><span class="n">sl</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">oldseq</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">return</span> <span class="n">sl</span><span class="p">.</span><span class="n">sequence_count</span> <span class="o">!=</span> <span class="n">oldseq</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">write_seqlock</span><span class="p">(</span><span class="n">SequenceLock</span> <span class="o">&amp;</span><span class="n">sl</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">sl</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class="line">  <span class="o">++</span><span class="n">sl</span><span class="p">.</span><span class="n">sequence_count</span><span class="p">;</span><span class="c1">//让count变为奇数，和读者声明自己的存在</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">write_sequnlock</span><span class="p">(</span><span class="n">SequenceLock</span> <span class="o">&amp;</span><span class="n">sl</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="o">++</span><span class="n">sl</span><span class="p">.</span><span class="n">sequence_count</span><span class="p">;</span><span class="c1">//让count恢复为偶数</span>
</span><span class="line">  <span class="n">sl</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">深度思考</h2>

<p>1，sequence lock和reader writer lock相比，有什么区别？</p>

<p>最主要的区别，如上所述，就是writer随时随地可以进行更新，不会出现writer starvation的情况。正因为如此，如果update heavily，那么可能造成reader starvation。然而，正如我们一早所说的，sequence lock用于read mostly的situation。因此，reader starvation几乎不会发生。</p>

<p>reader端并不需要加锁，只在极少情况下需要重试而已。因此，从某种角度来说，sequence lock是一种乐观锁。</p>

<p>2，sequence_count声明为<code>uint32_t</code>是否可以？</p>

<p>看你的writer更新的频率。假如你的writer每小时才更新一次，那么一天更新24次，一个月更新720次，一年才262800次，一百年才26280000次，是没有溢出危险的。如果每纳秒更新一次呢？算算看。</p>

<p>我知道，C语言uint32_max（奇数）再自增1之后溢出会回滚到0（偶数）不会影响到程序的正确性，但是好的程序个人认为不应该对此有依赖。</p>

<p>3，使用sequence lock可能会有什么坑？</p>

<p>假如我们的临界资源是这样的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">something</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>reader进入临界区后读取p，存放在自己的变量something *q里，然后返回。之后writer对p进行了free操作；如果reader之后使用<code>*q</code>将发生错误。对于这种情况，需要使用值拷贝语义，或者通过引入<a href="http://www.yebangyu.org/blog/2015/12/10/introduction-to-hazard-pointer/">hazard pointer</a>等其他机制来避免内存释放问题。不仅如此，实际上在临界区里，reader都不可以使用<code>*p</code>，这是因为和reader writer lock不同，sequence lock是不保证writer的不存在的，也就是说在临界区里，是可能随时有writer对p进行释放等操作的，这也是它和读写锁的最大不同。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String与Copy On Write]]></title>
    <link href="http://www.yebangyu.org/blog/2016/06/04/copy-on-write-in-string-and-soupen/"/>
    <updated>2016-06-04T18:13:27+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/06/04/copy-on-write-in-string-and-soupen</id>
    <content type="html"><![CDATA[<h2 id="copy-on-write">什么是Copy On Write</h2>

<p>Copy On Write(COW)作为一种优化技术被广泛使用，在string的实现中也不例外。考虑如下的代码：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&quot;1234&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>第二行，通过调用copy constructor（注意，这里调用的是copy constructor，而不是copy assignment，因为它是从无到有构造对象，而不是设置已有对象）构造对象t，第三行对t中的某个元素进行只读操作。</p>

<p>如果让你实现copy constructor，你会怎么做呢？教科书里的、简单的实现大概是这样：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">string</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">data_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">string</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">data_</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data_</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="cm">/*加1是考虑\0*/</span><span class="p">];</span>
</span><span class="line">  <span class="n">strcpy</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data_</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>好了，既然只是对t进行只读，那么就没完全必要分配内存、拷贝字符串等昂贵操作了，而是复用s的字符串空间即可。这就是我们要谈到的string中的COW。</p>

<h2 id="copy-on-write-1">如何实现Copy On Write</h2>

<p>显然，现在是有多个对象绑定或者说涉及或者说引用到某个字符串缓冲区上了。事实上，正如你能想到的，引用计数（Reference Counting，RC）是实现COW的重要基础。当执行上面最上面代码的第二行时，并不为t分配内存、拷贝字符串，而是相应的字符串的引用计数加1即可。</p>

<p>那么，引用计数应该放在哪里呢？它是string类的普通成员么？不行，这样子每个string对象都有一个引用计数了；成为string类的静态成员变量么？也不行，这样子每个类都只有一个引用计数了。</p>

<p>实际上，我们应该把buffer和引用计数抽离出来，单独放到某处。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">struct</span> <span class="n">stringvalue</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">data_</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">rc_</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">class</span> <span class="nc">string</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="n">stringvalue</span> <span class="o">*</span><span class="n">sv_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">string</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">sv_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">sv_</span><span class="p">;</span>
</span><span class="line">  <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">sv_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rc_</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>就这么简单，仅仅是attach，仅仅是增加引用计数。没有memory allocation，没有strcpy或者memcpy了。</p>

<p>如果仅仅是只读操作，那么这没任何问题。但是如果要写了呢？这时候没办法了，必须复制了。这就是所谓lazy evaluation，拖延战术(对应的是eager evaluation)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">set_char</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">char</span> <span class="n">new_char</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">sv_</span><span class="o">-&gt;</span><span class="n">rc_</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">//引用计数至少是2。说明除了自己，还有别人也引用到了这个buffer，不得不分配内存了，否则影响到别人了。</span>
</span><span class="line">    <span class="n">stringvalue</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">sv_</span><span class="p">;</span>
</span><span class="line">    <span class="n">sv_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">stringvalue</span><span class="p">();</span><span class="c1">//重新搞一份</span>
</span><span class="line">    <span class="n">sv_</span><span class="o">-&gt;</span><span class="n">data_</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">char_</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="n">strcpy</span><span class="p">(</span><span class="n">sv_</span><span class="o">-&gt;</span><span class="n">data_</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">char_</span><span class="p">);</span>
</span><span class="line">    <span class="n">sv_</span><span class="o">-&gt;</span><span class="n">rc_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="o">--</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">rc_</span><span class="p">;</span><span class="c1">//把原来的引用计数减1</span>
</span><span class="line">    <span class="c1">//......</span>
</span><span class="line"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">  <span class="c1">//......</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="copy-on-write-">Copy On Write 会带来什么问题？</h2>

<p>在单线程环境下，使用Copy On Write不容易出问题。不过多线程下，就险象环生了。</p>

<p>如果string内部做同步，那么这无疑增加了string的实现复杂度，并且STL的初衷其实是只考虑单线程环境的。同步操作无疑会带来大量的开销。</p>

<p>如果string内部不做同步，那么问题就来了。</p>

<p>加锁啊，加锁不就完了么？没那么容易。你看：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"> <span class="n">string</span> <span class="n">s</span><span class="p">;</span><span class="c1">//临界资源，全局变量</span>
</span><span class="line"> <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">   <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class="line">   <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line">   <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class="line">   <span class="c1">//这里可能读写操作t</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么，对t的操作也得加锁，如果有人通过t又复制了一个对象w，那么操作w的时候也得加锁，这太难了。这里，本质困难在于，可能会有很多对象，我们无法控制的对象都绑定到一块buffer上。</p>

<p>不过这样也没什么，毕竟不管有没有使用COW，使用STL时候都不应该对它有多线程安全的幻想。但是使用COW后确实更加危险，因为加锁的难度变大了，甚至都不知道在哪里加了。</p>

<p>想想看，在多线程环境下，假如string使用了COW优化，将c_str()返回的指针强制去掉const，以及operator []的读写可能会有什么问题。</p>

<h2 id="copy-on--write-">使用Copy On  Write 么？</h2>

<p>假如你是库设计和实现者，你会用COW么？</p>

<p><a href="https://github.com/yebangyu/Soupen">Soupen</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Soupen也实现了自己的string，并不使用Copy On Write(lazy evaluation)。而是使用eager evaluation，立即分配内存，立即拷贝。</p>

<p>在我们的应用中，调用copy constructor后对它进行写（而不是只读）的概率很大，拉拉扯扯各种引用计数加加减减，还不如直接分配+拷贝，反正后面也要做这个工作，何必自寻烦恼。</p>

<p>而且Soupen是服务器，不是类库，使用者是自己而不是广大用户，不需要考虑各种各样的情况。</p>

<p>当然，对于短字符串Soupen是做了优化的，可以参考<a href="http://www.yebangyu.org/blog/2016/05/15/stringinyedis/">这里</a>的源码解读。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ticket Lock]]></title>
    <link href="http://www.yebangyu.org/blog/2016/05/26/ticketlock/"/>
    <updated>2016-05-26T19:25:15+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/05/26/ticketlock</id>
    <content type="html"><![CDATA[<h2 id="section">简单回顾</h2>

<p><a href="http://www.yebangyu.org/blog/2016/03/04/petersonalgorithm/">上回</a> 我们介绍了peterson算法来实现spin lock，算法简单，实现简单，但是值得注意和留心的点很多。</p>

<p>粗略说来，peterson算法的主要缺点在于：</p>

<p>1，很难推广到n个线程(n&gt;=3)。原始的算法针对两个线程，如果想应用在多个线程的场景里，需要做一定的修改。</p>

<p>2，peterson算法的动机是仅仅使用load和store来实现互斥访问。然而，我们知道，现代体系结构下，CPU和编译器会对读写操作进行乱序，仅仅依靠读写操作而不使用memory barrier就编写正确的程序非常困难。</p>

<h2 id="ticket-lock">Ticket Lock</h2>

<p>在介绍Ticket Lock之前，我们首先分析一个妇孺皆知、地球人都知道的实现spin lock的方法（伪代码）：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cas</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span><span class="line">  <span class="c1">//get lock ! now , flag == 1</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>上面代码的第四行使用一个CAS原子操作：判断如果flag是否为0，如果为0，将它的值设置为1。判断和设置，所谓的test和set是一个原子操作，返回ture；如果不为0，则不设置，返回false。</p>

<p>这就是大名鼎鼎的<code>test-and-set</code>来实现spin lock。想想看，这种实现方式有什么缺点？</p>

<p>缺点一：不保证公平性，不满足FIFO先来先服务。假如有两个线程在第4行上spin，那么当持有锁的线程释放锁之后，这两个线程谁会成功拿到锁和谁先来spin没有任何直接关系。</p>

<p>缺点二：我们知道，不管CAS操作是否成功，都会产生大量的因为需要保证cache coherency而产生的message，降低性能。因此有一种改进方式：在CAS之前，先读取flag的值，当flag的值为0的时候，再尝试CAS。如下图的伪代码所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">cas</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="c1">//get lock ! now , flag == 1</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>改进后的算法叫做<code>test-and-test-and-set</code>，然而即使经过改进，上面的两个问题依旧存在。在很多场景下，我们希望：</p>

<p>1，保证公平性。</p>

<p>2，原子操作少些，少些，再少些。</p>

<p>3，没有饥饿。</p>

<p>这就涉及到我们要谈到的Ticket Lock。</p>

<p>想想我们去银行排队办业务：先拿个号，然后排队，叫到你的号就是服务你的时候了。没叫到你？老老实实等着吧（这里不考虑关系户走后门插队）。</p>

<p><a href="https://github.com/yebangyu/Soupen/blob/master/src/concurrency/soupen_ticket_spin_lock.h">Soupen</a>中实现了ticket spin lock，这里摘抄如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">SoupenTicketSpinLock</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="n">SoupenTicketSpinLock</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="n">next_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">      <span class="n">service_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">lock</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="kt">uint64_t</span> <span class="n">my_id</span> <span class="o">=</span> <span class="n">FETCH_AND_ADD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_id_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">      <span class="k">while</span><span class="p">(</span><span class="n">my_id</span> <span class="o">!=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">service_id_</span><span class="p">))</span> <span class="p">{}</span>
</span><span class="line">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="n">INC_ATOMIC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">service_id_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">next_id_</span><span class="p">;</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">service_id_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>第11行：获得自己的号，同时把号码递增。其中<code>fetch_and_add</code>是一个原子操作:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">fech_and_add</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">origin</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
</span><span class="line">  <span class="k">return</span> <span class="n">origin</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>顺便说一下，也有所谓的<code>add_and_fech</code>：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">add_and_fetch</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
</span><span class="line">  <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>区别就在于返回原来的值还是返回更新后的值</p>

<p>第12行：判断是否到自己的号了，否则就一直等待。</p>

<p>第17行：叫下一个人，和下一个人说，轮到你了。</p>

<p>关于<code>FETCH_AND_ADD</code>、<code>ACCESS_ONCE</code>和<code>INC_ATOMIC</code>的实现，请参考<a href="https://github.com/yebangyu/Soupen/blob/master/src/base/soupen_define.h">Soupen</a>中的相关代码。</p>

<p>公平性：不难看出，先来排队的人将优先获得服务。</p>

<p>性能：不难看出，和之前的不断CAS的版本相比，ticket lock算法中，一次lock调用只有一次原子操作开销。</p>

<p>饥饿：不难看出，每个线程都可以按照自己的排队顺序拿到锁，不会发生饥饿现象。</p>

<p>哈哈，如果过号呢？现实生活里，去银行排队可能因为时间太长不爽闪人了，银行叫人如果连叫三遍还没看到你就会叫下一个人了。</p>

<p>在这里，假如持有锁的线程crash了，来不及调用unlock，那么所有等待锁的线程都将一直spin，除非，哦，除非海量的线程来排队不断自增<code>next_id_</code>导致<code>next_id_</code>溢出回滚，然后重新等于<code>service_id_</code>。</p>

<p>如果持有锁的线程没有crash，它正常释放锁，而叫到的下一个线程之前crash了，那么也会导致所有排队的线程拿不到锁。</p>

<p>顺便说一下，(部分)Linux Kernel的spin lock就是用ticket lock实现的。更多细节可以参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/">这里</a>。</p>

<p>那么ticket lock是否完美呢？有什么惊人的缺点呢？请看<a href="http://www.yebangyu.org/blog/2016/08/21/mcslock/">下集</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Soupen源码解析之string实现]]></title>
    <link href="http://www.yebangyu.org/blog/2016/05/15/stringinyedis/"/>
    <updated>2016-05-15T20:21:10+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/05/15/stringinyedis</id>
    <content type="html"><![CDATA[<h2 id="section">写在最前</h2>

<p><a href="https://github.com/yebangyu/Soupen">Soupen</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Github请访问<a href="https://github.com/yebangyu/Soupen">这里</a> ，Python客户端请点击<a href="https://github.com/yebangyu/Soupen/blob/master/src/client/soupen_client.py">这里</a></p>

<p>在Soupen中有两种字符串(或者更准确的说，字节流)实现: SoupenString和SoupenNormalString。代码都在<code>src/ds/soupen_string.h</code>和<code>src/ds/soupen_string.cpp</code>文件里。两种实现都设计为大小写不敏感。</p>

<h2 id="soupennormalstring">SoupenNormalString</h2>

<p>以<code>\0</code>结尾的字符串实现，也就是说SoupenNormalString中的字符串都是以 <code>\0</code>结尾的。因此，对其施加任何类似于<code>strcmp</code>等传统C字符串函数都是安全的。</p>

<p>在实现时，针对短字符串，为了进一步优化效率，使用了<a href="http://www.yebangyu.org/blog/2016/03/25/fuckthefever/">柔性数组</a>技术来提高cache命中。</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class SoupenNormalString
</span><span class="line">{
</span><span class="line">//......
</span><span class="line">private:
</span><span class="line">  static const int64_t CHAR_LEN_THRESHOLD = 48;
</span><span class="line">  int64_t len_;
</span><span class="line">  char *data_;
</span><span class="line">  char buffer_data_[0];
</span><span class="line">};</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果字符串长度小于48(48是怎么得来的？Soupen使用jemalloc来分配内存，以64字节为一个块单位来分配内存。64位系统里，<code>len_</code>和<code>data_</code>各占用8个字节，cache line的大小一般为64字节，因此64 - 8 - 8 = 48。再次提醒，这里需要存储<code>\0</code>)，则会使用embedded string，也就是说，此时字符串的内容会和<code>len_</code>、<code>data_</code>分配在一块连续的内存中。由于局部性原理，在读取时，它们都会读到cache中，减少了cache miss，大大提高了性能。</p>

<p>不管字符串长度如何，不管是否使用<a href="http://www.yebangyu.org/blog/2016/03/25/fuckthefever/">柔性数组</a>技术来提高cache 命中，<code>data_</code>都会被设置为指向字符串的首地址。因此，外部总可以通过<code>data_</code>访问到字符串，</p>

<h2 id="soupenstring">SoupenString</h2>

<p>在SoupenString中的字符串存储，都不以<code>\0</code>结尾。因此，不能对其施加<code>strlen</code>等传统C字符串函数。</p>

<p>SoupenString中特别考虑了append函数的实现。为了减少内存分配，每次在append时，都会首先判断当前缓冲区是否够用，如果够用直接append；否则，这时候需要重新分配内存。注意，这时候我们会多分配一倍的内存，以防止下次append时不必要的内存分配动作。当然，这可能会造成内存浪费，但是对于优化时间消耗具有重要意义。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Soupen源码解析之rank实现]]></title>
    <link href="http://www.yebangyu.org/blog/2016/05/07/treappkskiplist/"/>
    <updated>2016-05-07T10:00:12+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/05/07/treappkskiplist</id>
    <content type="html"><![CDATA[<h2 id="section">写在最前</h2>

<p><a href="https://github.com/yebangyu/Soupen">Soupen</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Github请访问<a href="https://github.com/yebangyu/Soupen">这里</a> ，Python客户端请点击<a href="https://github.com/yebangyu/Soupen/blob/master/src/client/soupen_client.py">这里</a></p>

<p>和Redis一样，Soupen也同样支持rank功能，但是所使用的数据结构是Treap(Redis使用的是Skip List)。Treap和Skip List都是概率性的高级数据结构。</p>

<p>那么，什么是Treap呢？</p>

<h2 id="what-is-treap">What is Treap</h2>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/TreapAlphaKey.svg/440px-TreapAlphaKey.svg.png" alt="Treap" /></p>

<p>(图片来源于WikiMedia)</p>

<p>简单说来，Treap是这样的树：Treap中的每个节点至少包含key和优先级两个字段，其中key满足搜索树性质，优先级满足堆序性。如上图所示，数字是优先级字段，字母是key字段。其中优先级构成了一个大根堆。</p>

<p>也就是说，在Treap中，key组成了一个二叉搜索树，优先级组成了一个堆。所谓Treap = Tree + Heap。</p>

<!--more-->

<p>插入一个节点时，随机生成一个优先级。这时候可能堆序性被破坏，而这可以通过旋转来恢复。由于只可能有左右单旋转两种情形，因此它的代码编写比AVL树、Red-Black Tree要简单的多，并且可以证明旋转的期望次数小于2。</p>

<p>在Treap上的删除、插入、查找的期望时间复杂度都是O($lgn$)。</p>

<h2 id="soupen-pk-redis">Soupen PK Redis</h2>

<h3 id="soupentreap">Soupen中的Treap实现</h3>

<p>Soupen中的treap实现在<code>src/ds/soupen_treap.cpp</code>中，可以从<a href="https://github.com/yebangyu/Soupen/blob/master/src/ds/soupen_treap.cpp">这里</a>下载。</p>

<p>说明：</p>

<p>1，对于score相同的节点，我们通过它们的ele的字典序来决定序。</p>

<p>2，rank的思路也比较自然：从根开始，如果score小于节点的score，那么继续访问该节点的左子树；如果大于节点的score，说明该节点和该节点左子树的所有节点都小于score，因此score的rank应该加上左子树的大小，然后访问该节点的右子树。</p>

<p>所以，SoupenTreapNode中包含了size字段。注意，在计算某个节点的size字段时，除了左右子树，也把该节点本身考虑在内。</p>

<p>3，显然，递归地实现Treap比较方便和容易。</p>

<h3 id="section-1">测试程序</h3>

<p>我们将Soupen和Redis进行比较。其中Redis的代码来自于它的SkipList实现，不改变它性能的基础上，稍作简化和整理。</p>

<p>测试程序可以从这里下载：</p>

<p><a href="https://github.com/yebangyu/Soupen/blob/master/src/test/test_soupen_treap.cpp">Soupen</a></p>

<p><a href="https://github.com/yebangyu/Soupen/blob/master/src/test/test_redis_rank.cpp">Redis</a></p>

<p>编译链接这两个测试程序时，请记得加<code>-lrt</code>选项。</p>

<h3 id="section-2">测试结果</h3>

<p>测试环境是Ubuntu 14.04 64位系统 + 8GB内存 + gcc4.8，开启-O2优化选项。</p>

<p>对于200W个整数有序插入的测试结果：</p>

<p>Redis：insert，362263271ns = 0.36s，rank，172763924ns = 0.17s</p>

<p>Soupen：insert，300028059ns = 0.30s，rank，106218516ns = 0.11s</p>

<p>对于200W个整数随机打乱后插入的测试结果：</p>

<p>Redis：insert，1682160424ns = 1.68s，rank，1729983233ns = 1.73s</p>

<p>Soupen：insert，1484001788ns = 1.48s，rank，1182535652ns = 1.18s</p>

<p>可以看出不管在insert还是rank上，Soupen的性能都是要完胜Redis的。</p>

<h2 id="section-3">参考文献</h2>

<p>1，Mark Allen Weiss的《Data Structures &amp; Algorithm Analysis in C++》中介绍了Treap，这也是我第一次接触和知道Treap的地方。</p>

<p>2，《Introduction to Algorithms》中在某个章节里，以习题的形式介绍了Treap。</p>

<p>3，之前陈利人童鞋在微博上推荐了某大学的某学生写的Treap资料，他们都说好。我没看，也没兴趣。</p>

<p>4，<a href="http://www.cepis.org/upgrade/files/full-2004-V.pdf">A Disquisition on The Performance Behaviour of Binary Search Tree Data Structures</a> 这篇论文对常见的平衡树进行了全面的实验性分析，强烈推荐。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论汉武帝独尊儒术]]></title>
    <link href="http://www.yebangyu.org/blog/2016/05/01/hanwudi/"/>
    <updated>2016-05-01T12:27:57+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/05/01/hanwudi</id>
    <content type="html"><![CDATA[<p>汉武帝为什么独尊儒术？</p>

<p>在讨论这个问题前，先让我们回忆一个非常基本的常识，还是不厌其烦的交待两个人物的关系：汉武帝和窦太后。窦太后是汉文帝的老婆，汉景帝的妈妈，汉武帝的奶奶。</p>

<p><img src="http://img1.gtimg.com/rushidao/pics/hv1/116/137/2059/133921526.jpg" alt="窦太后" /></p>

<p>汉武帝为什么独尊儒术呢？大家都说，这是因为汉武帝推崇并认可儒家学说。然而，以我个人的浅见，汉武帝其实并不是多么喜欢儒家思想，也不懂儒家学说。</p>

<!--more-->

<p>试看他做的这么多事情，有哪一件是按照儒家学说来做的？建造的宫殿非常奢侈，对外连年发动战争，其实都是和儒家思想背道而驰的。</p>

<p>那么他为什么独尊儒术呢？我的看法是有三个原因：1，对窦太后的报复。2，社会形势所使然。3，儒家学说满足了他的某种需求。</p>

<p>先说第一点。</p>

<p>我们知道，窦太后是汉武帝的奶奶，汉景帝的老妈。我们知道，自从西周封建后，皇位继承使用的是嫡长子制度。然而，景帝时，窦太后就三番五次要汉景帝死后传位给她的小儿子、汉景帝的弟弟、梁孝王刘武。这种思想不能说是奇葩，然而在封建社会也是让人大吃一惊的。所幸后面发生了一系列的事情，汉武帝才当上了皇帝。这当然很不容易，因为汉武帝本身不是嫡长子，甚至不是皇后所生。</p>

<p>汉武帝上台后，窦太后辅政。说来也是有意思，汉景帝为什么在临死的时候会让他的老妈辅政呢？这里面的原因其实很复杂。我们知道西汉初年是采用一种虚君实相的制度：皇帝只作为国家元首，而实事都是宰相做的。在西汉，宰相不仅重要，而且很有实权，这其实是很危险的，汉景帝估计是考虑到了这个问题。</p>

<p>外戚就一定安全吗？也不是。然而当时的人对这个还没有深刻的认识。有人说，不是吧，吕后不就是一个活生生的教训吗？然而，当时的人只会认为是吕后不好，而不是外戚的制度不好。</p>

<p>窦太后是笃信黄老的人。我们知道，在西汉初年，国家的政治意识形态是道家思想（注意，是道家，不是道教。这两者风马牛不相及）。这也是有社会背景和根据的。刘邦打下天下时，因为多年的战争，百姓苦逼，生产力低下，当务之急就是发展和生产。因此道家的无为思想就很合适了。所谓<code>治大国者，若烹小鲜</code>，就是这个时期的人的普遍思想。</p>

<p>汉武帝没有选择窦太后推崇的道家思想，也没有选择法家思想。然而，他实际上是表面儒家、实际法家。这个后面会再说。</p>

<p>所以你不难理解为什么汉武帝临死前居然杀了汉昭帝的亲生母亲，大概是对外戚干政深恶痛绝了，然而却立了霍光、金日磾等四位辅政大臣。这其实也是不好的，别以为霍光真的是和伊尹一样，这个我们也以后再说。</p>

<p>现在说第二个原因，社会形势所使然。</p>

<p>上文说过，西汉初年，国家的意识形态是道家，这是和社会形势和背景相关的。那么到了中汉呢？发展到了一定的程度，再继续用道家思想，恐怕不灵了吧？这时候就要改革，而论到改革，自然是儒家思想最擅长了。所以说，这也是当然社会形势和背景所使然。不以人的意志为转移的。</p>

<p>当时儒家和道家的争论已经很普遍，说明很多人已经开化。有一次，汉景帝召开一次会议，讨论汤武革命问题。所谓汤武革命，就是商汤灭掉夏桀，周武王灭掉殷纣王。都是因为君主暴虐无道，臣子替天行道灭了主子。</p>

<p>言外之意，当君主无道时，作为臣子，是否可以干掉他呢？</p>

<p>讨论会上，大家的观点不一。道家人物认为不对，君就是君，臣就是臣，君主再无道，臣子也不能干掉主子。这是造反。</p>

<p>但是儒家人物就认为这是合法。儒家代表人物辕固认为，按照这个逻辑，难道汉高祖刘邦灭了秦王朝也是不对的？</p>

<p>这就让人两难了。不过这里似乎有一个问题：儒家不是强调奴性吗，奇怪，这里它怎么会支持君主无道时臣子可以反抗呢？这还是儒家思想吗？</p>

<p>其实很多人对儒家思想了解和认识不够，总以为儒家思想是为统治者服务的，让老百姓和大臣做牛做马，甚至做走狗。然而，实际上并不是这样。诸位不是读过《孟子》吗？《孟子》里说，<code>民为贵，社稷次之，君为轻</code>。其实就是强调民权的。更进一步，《孟子》里说，<code>君之视臣如土芥，则臣视君如寇仇</code>。<code>寇仇，何服之有？</code>，其实上，就是承认了当君无道时，臣子其实是没有尽忠的义务的，是有自卫的权利的。</p>

<p>说的远了。也就是说，从这次的辩论会来说，儒家思想已经在当时渐渐抬头（虽然后来辕固差点被窦太后给喂（野）猪了）。加上当时的社会背景，自然儒家思想被重用，也是非常自然而然的事了。历史潮流，岂人事哉？</p>

<p>第三点，就是儒家思想满足了汉武帝的某种需求。什么需求？汉武帝是一个非常讲究排场和形式主义的人。而我们知道，儒家是出自礼官的，孔子就是推崇周公所创立的礼乐文化制度的，制礼作乐，这个是儒家擅长的。因此，汉武帝看重儒家。然而前面说过，汉武帝并不是真正的推崇和了解儒家思想，他care的是改正朔、易服色之类的礼仪制度，对于董仲舒提出的“限田”等策略都没有采纳。</p>

<p><img src="http://blogfile.ifeng.com/uploadfiles/blog_attachment/1107/13/1298913_2fae634cbac0898d770552633ccfb518.jpg" alt="汉武帝" /></p>

<p>汉武帝表面尊儒，实际上实行的是法家的那一套。我有几个朋友，对先秦诸子思想存在误读，非常深的误解，以为法家就是好的，儒家就是奴性、统治者服务。然而实际上并不是。所谓法家思想，是对老百姓采取高压统治，是很push的，老百姓是受苦的。试看武帝之前并没有什么起义，而武帝之后起义较多就可以得知。</p>

<p>最好的制度，我个人认为，应该是汉宣帝（刘病已）采取的<code>霸王道杂之</code>的方法。霸，也就是法家。王，也就是儒家。意思是，对官僚阶级，采用法家，施加督责，对百姓，采取儒家制度，仁爱制度。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction To Performance Optimization]]></title>
    <link href="http://www.yebangyu.org/blog/2016/04/22/optimization/"/>
    <updated>2016-04-22T23:13:13+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/04/22/optimization</id>
    <content type="html"><![CDATA[<h2 id="section">写在最前</h2>

<p>本文针对<strong>C++</strong>和<strong>linux</strong>环境，但是思想和方法，却对其他语言和环境同样适用。很可供参考的。</p>

<h2 id="section-1">优化前</h2>

<p>1，确定优化是必须要做的。</p>

<p>如果程序已经跑的足够快了，内存使用也足够省了，那么完全没有优化的必要。什么是足够呢？能够满足当前的业务和需求。因此，如果不是绝对必要，不要优化。</p>

<p>这是因为虽然优化不是万恶之源，但是优化可能会带来问题。为了提升一点点性能就得绞尽脑汁、辗转反侧；它可能让之前只需要一两行逻辑很清晰的代码，变成很难理解的高度优化的实现。优化很多时候某种程度上让代码可读性和可维护性变差。</p>

<p>2，确定该做的优化都做了</p>

<!--more-->

<p>有两个方法可以免费地、快速地提高效率：</p>

<p>第一个是使用<strong>release</strong>模式。如果您的程序在<strong>debug</strong>模式下表现不佳，那么可以尝试使用<strong>release</strong>模式进行编译链接。一般说来，这也是发布程序的默认模式。</p>

<p>第二是开启编译器优化。例如<strong>g++</strong>就提供了多个级别的优化选项，一般使用<strong>O2</strong>。</p>

<p>3，确定做了优化前的准备工作</p>

<p>最重要的一点是对程序的性能进行详细分析，找出瓶颈段<strong>（hot spot</strong>）。这很重要，否则，可能导致在错误的方向上越走越远。例如一个程序由函数<strong>f</strong>和<strong>g</strong>构成，<strong>f</strong>花费了<strong>2s</strong>，<strong>g</strong>花费了<strong>100ns</strong>，那您把<strong>g</strong>从<strong>100ns</strong>优化为<strong>20ns</strong>，对系统又有什么帮助呢？<strong>f</strong>才是大头啊。</p>

<p>因此，这里就会有三个问题：</p>

<p>第一，如何定位程序瓶颈段？</p>

<p>要是有一个工具，能够告诉我系统模块的开销比例，那就太好了。有这样的工具吗？有的。<strong>Linux</strong>下的<strong>perf</strong>就是。<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">这里</a>是对<strong>perf</strong>非常好的<strong>tutorial</strong>，强烈建议初学者阅读。简单说来，一条命令即可：</p>

<pre><code>sudo perf record -g ./yourprograme
</code></pre>

<p>第二，我想给我的程序的某个函数计时，应该怎么做？</p>

<p>有很多方法，强烈建议您阅读我的<a href="http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux/">这篇</a>博客，很可供参考。我个人比较喜欢用<strong>timespec</strong>，原因是：知道它的人不多；它可以精确到纳秒；它不受系统时钟的影响（<strong>gettimeofday</strong>显然会，因为它就是读取系统时钟嘛）。</p>

<p>第三，优化后，函数变快了，系统变快了多少？</p>

<p>哦，回忆一下我们本科计算机体系结构里的<strong>Amdahl</strong>定律。如果您没学过这个定律，或者早已还给老师，那么<a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">这里</a>的内容可能对您有帮助。</p>

<h2 id="section-2">优化中</h2>

<p>一旦确定要优化，并且定位了瓶颈段，那么就是想尽一切办法进行加速了。个人总结的一些比较有效的思路和方法：</p>

<p>0，<strong>cache friendly access pattern</strong></p>

<p>尽可能利用<strong>cache</strong>，编写<strong>cache friendly</strong>代码。例子，比如说非常著名的二维数组按行按列访问问题。</p>

<p>1，算法和数据结构层面</p>

<p>使用合适的、高效的数据结构和算法，往往能带来很大的提升。不过，前提是，您需要对您的需求进行认真分析。<strong>find、search、insert、successor、del、min、max</strong>这些操作，哪些是您期望需要非常高效的？哪些操作是您业务里经常出现的？</p>

<p>您需要对以下数据结构和算法有所了解：</p>

<p>哈希表：<strong>O(1)</strong>期望查找时间让它常常成为除了数组之外的首选，尤其是当查找非常关键时。只知道<strong>Separate Chaining</strong>和<strong>Open Addressing</strong>？那您<strong>out</strong>了。建议您阅读我的<a href="http://www.yebangyu.org/blog/2015/12/19/cuckoo-hashing/">这篇</a>讲解<strong>cuckoo hashing</strong>的博客。</p>

<p>跳表：说到<strong>O(lgn)</strong>的<strong>insert、find、del</strong>，很多人想到二叉搜索树，由于非平衡的二叉搜索树有退化为<strong>O(n)</strong>的风险，因此很多场景需要平衡树。<strong>B</strong>树？红黑树？太<strong>heavy</strong>了。有时候，您需要跳表，真的，很需要。它足够简单，而且很多时候就能满足您的需求。除此之外，<strong>Treap</strong>也是一种随机的数据结构，我实现的大规模分布式数据库<a href="https://github.com/yebangyu/Soupen">Soupen</a>里就有提供相应的实现，您可以参考我的这篇<a href="http://www.yebangyu.org/blog/2016/05/07/treappkskiplist/">博客</a>。</p>

<p><strong>Sunday</strong>算法：字符串匹配里，<strong>KMP</strong>算法是大名鼎鼎了。谁让<strong>Knuth</strong>是大佬呢？可是，您是否知道<strong>Sunday</strong>算法？<strong>Sunday</strong>算法什么时候会比<strong>KMP</strong>高效而且高效地多？</p>

<p><strong>string.h</strong>里提供的算法：包括<strong>memcmp、memcpy、memmem、memmove</strong>等。当您想手工实现这些函数，正在写一大堆<strong>while</strong>循环时，请优先选择这些库函数。</p>

<p>排序算法：快速排序，非常常见、常用。那么，如何编写一个高效的快速排序？建议您阅读我的<a href="http://www.yebangyu.org/blog/2016/03/09/quicksort/">这篇</a>博客。</p>

<p>2，将小但是频繁调用的函数内联。注意，<strong>gcc</strong>有提供强制内联的<strong>feature</strong>，也就是<code>__attribute__((always_inline))</code></p>

<p>3，为分支预测适当加上<strong>likely</strong>或者<strong>unlikely</strong>。请注意，<strong>if</strong>语句并不可怕，可怕的是分支预测失败。这正和锁并不可怕一样，因为加锁和释放锁其实很快，可怕的是锁冲突。所以，您需要了解这两组宏：</p>

<pre><code>#define  likely(x)        __builtin_expect(!!(x), 1) 
#define  unlikely(x)      __builtin_expect(!!(x), 0) 
</code></pre>

<p>4，消除<strong>if</strong>语句。比如说如下代码：</p>

<pre><code>if (a &gt; 0 ) b += 2; else b+= 1;
</code></pre>

<p>那么可以消除为<code>b += 1 + (a &gt; 0);</code></p>

<p>5，查表法。将反复使用的、不大的、静态的数据事先计算好，存在表格里，需要的时候，直接去查，避免计算。</p>

<p>还有很多很多。就看您的知识面和经验了。</p>

<p>有一个错误的想法，很值得在这里说。很多资料上写着：用移位代替乘除法。因此很多人的代码里充斥着大量的<code>&gt;&gt;1</code> 以及 <code>&lt;&lt;1</code>，美其名曰性能优化。</p>

<p>事实上，现在的编译器很聪明了，一点都不傻，不信您可以直接写<code>a / 2</code> 然后看看开启<strong>-O2</strong>选项后的汇编代码。结果会让您赞叹的。上面的左移一位、右移一位没有任何必要。</p>

<p>正常情况下，请按照逻辑需要直接写代码。现代编译器真的已经很牛逼了。因此，您应该重点关注算法、<strong>Cache</strong>、分支预测等层面。</p>

<h2 id="section-3">优化后</h2>

<p>优化后，请记得再次对您的程序进行<strong>profiling</strong>，确保优化是有效的。</p>

<p>别偏听偏信，别坚信<strong>KMP</strong>一定比暴力算法快，别盲信教科书、博客、资料里的说法，别跪舔大佬！请实际测试！测试！！再测试！！！</p>

<p>一切以您的环境、以您的系统、以您的测试为准。没有权威。</p>

<h2 id="section-4">参考资料</h2>

<p>专门针对<strong>C++</strong>和<strong>Linux</strong>的优化的书，不多。但是有一些零碎的、七七八八的资料，编程珠玑啊，深入理解计算机系统啊，还有最近刚刚出版的<strong>optimized c++</strong>啊等等。</p>

<p>有好心的网友在Github上维护了一个<a href="https://github.com/fenbf/AwesomePerfCpp">项目</a>，分享了不少C++性能优化相关的资料。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Literal In C++]]></title>
    <link href="http://www.yebangyu.org/blog/2016/04/10/stringliteralincpp/"/>
    <updated>2016-04-10T22:05:21+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/04/10/stringliteralincpp</id>
    <content type="html"><![CDATA[<p>最近被一个很基本的知识点给咬伤，虽然之前知道这个问题，但是写代码的时候不小心还是容易犯错。简单记录一下。</p>

<h2 id="section">提出问题</h2>

<p>之前，代码里拥有如下数组：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">COLORS</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;black&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;green&quot;</span>
</span><span class="line">                        <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在需要以追加的形式，添加一个yellow的颜色。粗心之下，我写成了：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">COLORS</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;black&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;green&quot;</span>
</span><span class="line">                         <span class="s">&quot;yellow&quot;</span>
</span><span class="line">                        <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在某处代码，我使用了COLORS[3]，类似于</p>

<p><code>cout&lt;&lt;COLORS[3]&lt;&lt;endl;</code></p>

<p>程序执行后，就崩溃了。</p>

<h2 id="section-1">分析问题</h2>

<p>问题出在，在追加的代码中的第4行，漏掉了一个逗号！！！正确的形式应该是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">COLORS</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;black&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="c1">//这里应该有个逗号！！！</span>
</span><span class="line">                         <span class="s">&quot;yellow&quot;</span>
</span><span class="line">                        <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在没有逗号下，编译器将”green”和”yellow”当做一个字符串，也就是”greenyellow”，因此，COLORS[2]其实是”greenyellow”，而COLORS[3]是未显式初始化的，为NULL。因此使用COLORS[3]程序崩溃。</p>

<h2 id="section-2">解决问题</h2>

<p>上面已经解决了问题。这里小小补充下:</p>

<p>在C++中，如下几种形式结果是一样的，表示的是同一个字符串”hello, world” ：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, world&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, &quot;</span>
</span><span class="line"><span class="s">&quot;world&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, \</span>
</span><span class="line"><span class="s">world&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, &quot;</span>  <span class="s">&quot;w&quot;</span>  <span class="s">&quot;orld&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Soupen源码解析之itoa实现]]></title>
    <link href="http://www.yebangyu.org/blog/2016/04/04/itoa-in-yedis/"/>
    <updated>2016-04-04T12:37:06+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/04/04/itoa-in-yedis</id>
    <content type="html"><![CDATA[<h2 id="section">写在最前</h2>

<p><a href="https://github.com/yebangyu/Soupen">Soupen</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Github请访问<a href="https://github.com/yebangyu/Soupen">这里</a> ，Python客户端请点击<a href="https://github.com/yebangyu/Soupen/blob/master/src/client/soupen_client.py">这里</a></p>

<h2 id="section-1">提出问题</h2>

<p>如何用C/C++实现正确的、可移植的、高效的、对所有整数都work的itoa函数？</p>

<p>原型如下</p>

<p><code>int itoa(char *buffer, int64_t value);</code></p>

<p>将value转为字符串后存在buffer中，返回字符串的长度。</p>

<!--more-->

<h2 id="section-2">分析问题</h2>

<p>这还不容易么？很容易写出这样的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">itoa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个实现，有什么问题？问题是显而易见的：当value为负数时，在第6行，例如value = -123，如果tmp % 10 = -3，而-3 + ‘0’并不是期望的结果。</p>

<p>有些人说，这还不容易吗？把负数都搞成正数，用它的绝对值来计算，不就行了吗？于是很容易写出这样的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">itoa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">value</span> <span class="p">:</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还是有问题，注意第4行。回忆一下本科时候所学的计算机组成原理，我们知道，对于有符号整数，它的最大值和最小值是不对称的，绝对值差1。其中，64位有符号整数的范围为[-9223372036854775808, 9223372036854775807]</p>

<p>因此，在第4行，如果value是INT64_MIN，对它求绝对值-value的结果其实已经超出了64位有符号整数可以表示的范围，这里已经溢出了！！！</p>

<p>哦哦，这好办，对INT64_MIN单独处理行不行？</p>

<p>行，但是代码会非常不优雅了。</p>

<p>Matthew Wilson大神的Efficient Integer to String Conversions文章里，使用如下的trick，来处理这些问题。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">itoa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">digits</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;9&#39;</span><span class="p">,</span><span class="sc">&#39;8&#39;</span><span class="p">,</span><span class="sc">&#39;7&#39;</span><span class="p">,</span><span class="sc">&#39;6&#39;</span><span class="p">,</span><span class="sc">&#39;5&#39;</span><span class="p">,</span><span class="sc">&#39;4&#39;</span><span class="p">,</span><span class="sc">&#39;3&#39;</span><span class="p">,</span><span class="sc">&#39;2&#39;</span><span class="p">,</span><span class="sc">&#39;1&#39;</span><span class="p">,</span><span class="sc">&#39;0&#39;</span><span class="p">,</span><span class="sc">&#39;1&#39;</span><span class="p">,</span><span class="sc">&#39;2&#39;</span><span class="p">,</span><span class="sc">&#39;3&#39;</span><span class="p">,</span><span class="sc">&#39;4&#39;</span><span class="p">,</span><span class="sc">&#39;5&#39;</span><span class="p">,</span><span class="sc">&#39;6&#39;</span><span class="p">,</span><span class="sc">&#39;7&#39;</span><span class="p">,</span><span class="sc">&#39;8&#39;</span><span class="p">,</span><span class="sc">&#39;9&#39;</span><span class="p">};</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zero</span> <span class="o">=</span> <span class="n">digits</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">];</span><span class="c1">//下标可能是负数</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这下没问题了吧？有。</p>

<p>问题出在第8、9行。</p>

<p>举个例子，请问，-123 / 10结果是多少？-123 % 10 呢？</p>

<p>因为<code>-123 = (-12) * 10 + (-3)</code> 因此<code>-123 / 10 = -12</code>，同时<code>-123 % 10 = -3</code></p>

<p>但是！</p>

<p>因为<code>-123 =(-13) * 10 + 7</code> 因此<code>-123 / 10 = -13</code>，同时<code>-123 % 10 = 7</code></p>

<p>两种可能的结果？事实上，C++98和C++03标准并没有对被除数和除数不都为正数时的情形进行明确的说明，第8、9行的结果是未定义的，是很不可移植的。</p>

<p>如果在某个具体的实现下，<code>-123 / 10 = -13</code>，并且 <code>-123 % 10 = 7</code> ，那么以上代码结果不对。</p>

<h2 id="section-3">解决问题</h2>

<p>Soupen中实现了itoa，代码在<code>src/server/soupen_order.cpp</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">YEDIS_MUST_INLINE</span> <span class="kt">int64_t</span> <span class="nf">int2char</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">remainder_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="sc">&#39;9&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span> <span class="p">},</span><span class="c1">//正数</span>
</span><span class="line">
</span><span class="line">                                                <span class="p">{</span> <span class="sc">&#39;9&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span> <span class="p">}</span> <span class="p">};</span><span class="c1">//负数</span>
</span><span class="line">
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">quotient_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span><span class="c1">//正数</span>
</span><span class="line">
</span><span class="line">                                               <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">};</span><span class="c1">//负数								  </span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">digit</span> <span class="o">=</span> <span class="n">remainder_offset</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">  <span class="k">const</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">quotient_offset</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">digit</span><span class="p">[</span><span class="n">remainder</span><span class="p">];</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="n">remainder</span><span class="p">];</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过两个二维数组，很巧妙、完美的解决了这个问题。它对于[INT64_MIN, INT64_MAX]中的任何一个数都是正确的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Soupen: A High Performance Nosql]]></title>
    <link href="http://www.yebangyu.org/blog/2016/03/31/yedis01/"/>
    <updated>2016-03-31T23:53:16+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/03/31/yedis01</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/yebangyu/Soupen">Soupen</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Github请访问<a href="https://github.com/yebangyu/Soupen">这里</a> ，很烂的一个Python客户端请点击<a href="https://github.com/yebangyu/Soupen/blob/master/src/client/soupen_client.py">这里</a>。</p>

<h2 id="section">动机</h2>

<p>开发Soupen的主要原因是想通过这个项目，进一步提高和熟悉C++服务器端开发相关的技术和知识。</p>

<h2 id="section-1">特性</h2>

<p>换句话说，它和Redis相比有什么不同？</p>

<!--more-->

<p>目标：Redis有的，Soupen都有。Redis没有的，但是很实用的，Soupen也有，比如说Cuckoo Hashing Map等。再比如说Treap，这玩意其实用来实现倒排索引非常高效，细节请参考Sigir2013的论文。</p>

<p>但是不打算兼容它，API和协议也和它不同。</p>

<h2 id="section-2">进度</h2>

<p>目前已经支持</p>

<blockquote>
  <ul>
    <li>Standard Bloom Filter</li>
    <li>Trie</li>
    <li>切换数据库</li>
  </ul>
</blockquote>

<p>还有很多工作要做，包括但是不局限于：</p>

<h3 id="bug-">Bug 修复</h3>

<p>毕竟，稳定和正确是第一位的。</p>

<h3 id="section-3">数据结构</h3>

<blockquote>
  <ul>
    <li>List</li>
    <li>HashMap</li>
    <li>Priority Queue</li>
    <li>Skip List</li>
    <li>Treap</li>
    <li>Kd tree</li>
    <li>Cuckoo Hashing Map</li>
    <li>d-left hashing based Couting Bloom Filter</li>
  </ul>
</blockquote>

<h3 id="section-4">性能优化</h3>

<p>超过或者达到Redis。</p>

<h3 id="section-5">分布式</h3>

<p>单机的内存数据库意义不大。</p>

<h2 id="section-6">截图</h2>

<h3 id="server">server</h3>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/server.png" alt="server" /></p>

<h3 id="client">client</h3>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/client.png" alt="client" /></p>

<p>不过，Soupen是写着玩的，别太当真。</p>
]]></content>
  </entry>
  
</feed>
